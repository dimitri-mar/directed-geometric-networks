/*
 *
 * This class provides the functions to embed a graph in the S1 space.
 *
 * Compilation requires the c++11 standard (to use #include <random>), the Eigen, the Spectra as
 * well as the hyp2f1.a library.
 *
 * Author:   Antoine Allard
 * WWW:      antoineallard.info
 * Version:  1.0
 * Date:     May 2018
 *
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *
 */

#ifndef FITTING_DIRECTEDS1_HPP_INCLUDED
#define FITTING_DIRECTEDS1_HPP_INCLUDED

// Standard Template Library
#include <algorithm>
// #include <chrono>
#include <cmath>
#include <ctime>
#include <complex>
#include <exception>
#include <fstream>
#include <functional>
#include <iomanip>
#include <iostream>
#include <map>
#include <random>
#include <set>
#include <sstream>
#include <string>
#include <utility>
#include <vector>
// // Eigen library
// #include "Eigen/Core"
// #include "Eigen/SparseCore"
// // Spectra library
// #include "Spectra/GenEigsSolver.h"
// #include "Spectra/MatOp/SparseGenMatProd.h"

// Custom library for specific Gaussian hypergeometric functions.
#include "hyp2f1.hpp"

#include "pgl/directedgraph.h"
#include "pgl/inputoutput/inputoutput.h"
#include "pgl/metrics/directed.h"

class fitting_directedS1_t
{
  private:
    // pi
    const double PI = 3.141592653589793238462643383279502884197;
  // Flags controlling options.
  public:
    // Allows the initial angular positions to have large gaps.
    bool ALLOW_LARGE_INITIAL_ANGULAR_GAPS = true;
    // Characterizes the inferred ensemble (generates CHARACTERIZATION_NB_GRAPHS graphs and measure
    //   various structural properties).
    bool CHARACTERIZATION_MODE = false;
    // Also write a raw file containing the inferred coordinates without any "commented" lines.
    bool CLEAN_RAW_OUTPUT_MODE = false;
    // Has a custom value for beta been provided?
    bool CUSTOM_BETA = false;
    bool CUSTOM_MU = false;
    bool CUSTOM_NU = false;
    // Indicates whether the number of graphs generated during the characterization phase is the default value ot not.
    bool CUSTOM_CHARACTERIZATION_NB_GRAPHS = false;
    // Using already inferred coordinates.
    bool CUSTOM_INFERRED_COORDINATES = false;
    // Has a custom name for various output files generated by the program been provided?
    bool CUSTOM_OUTPUT_ROOTNAME_MODE = false;
    // Has a custom value for the seed been provided?
    bool CUSTOM_SEED = false;
    // Will the kappas be adjusted after the angular positions inferred?
    bool KAPPA_POST_INFERENCE_MODE = true;
    // Will or will not position the vertices to maximize the log-likelihood.
    bool MAXIMIZATION_MODE = true;
    // Does not provide any information during the embedding process.
    bool QUIET_MODE = false;
    // Refining only the already inferred positions.
    bool REFINE_MODE = false;
    // Provides various files that characterize the inferred ensemble.
    bool VALIDATION_MODE = false;
    // Print information about the embedding process on screen instead than on the log file.
    bool VERBOSE_MODE = false;

  // Global parameters.
  public:
    // Name of the file containing the previously inferred parameters.
    std::string ALREADY_INFERRED_PARAMETERS_FILENAME;
    // Minimal/maximal value of beta that the program can handle (bounds).
    double BETA_ABS_MAX = 25;
    double BETA_ABS_MIN = 1.01;
    // Number of graphs to generate during the characterization of the inferred ensemble.
    int CHARACTERIZATION_NB_GRAPHS = 100;
    // Number of new positions to try.
    int MIN_NB_ANGLES_TO_TRY = 100;
    // // Parameter governing the refinied search for optimal position during the maximization phase.
    // int CLOSE_ANGULAR_RANGE_FACTOR = 2;
    // Edgelist filename.
    std::string EDGELIST_FILENAME;
    // Number of points for MC integration in the calculation of expected clustering.
    int EXP_CLUST_NB_INTEGRATION_MC_STEPS = 200;
    // Number of steps for integration for the expected distance between adjacent vertices.
    // int EXP_DIST_NB_INTEGRATION_STEPS = 1000;
    // Maximal number of attempts to reach convergence of the updated values of kappa.
    int KAPPA_MAX_NB_ITER_CONV = 1000;
    // // Criterion for the change of the nature of the criterion for the convergence during the
    // //   maximization of the angular positions.
    // int LIMIT_FOR_CONVERGENCE_CRITERION = 625;
    // Criterion for changing the calculation of the log-likelihood.
    // int NB_VERTICES_IN_CORE = 1000;
    // Maximal number of steps in the maximization phase.
    // int MAX_NB_ITER_MAXIMIZATION = 15;
    // // Maximal angular step when looking for optimal position.
    // int MINIMAL_ANGULAR_RESOLUTION = 100;
    // Minimal value for the convergence of maximization.
    // double MINIMAL_ANGULAR_CONVERGENCE_THRESHOLD = 0.005;
    // // Minimal values for 2 sigmas when drawing new angles to test.
    // double MIN_TWO_SIGMAS_NORMAL_DIST = PI / 6;
    // Various numerical/convergence thresholds.
    double NUMERICAL_CONVERGENCE_THRESHOLD_1 = 1e-2;
    double NUMERICAL_CONVERGENCE_THRESHOLD_2 = 1e-2;
    // double NUMERICAL_CONVERGENCE_THRESHOLD_3 = 0.5;
    // double MAXIMIZATION_CONVERGENCE_THRESHOLD = 0.01;
    double NUMERICAL_ZERO = 1e-5;
    // // Parameter governing the refinied search for optimal position during the maximization phase.
    // int REFINED_MAX_STEP_LENGTH_DIVISOR = 5;
    // Rootname of output files.
    std::string ROOTNAME_OUTPUT;
    // Random number generator seed.
    int SEED;
  private:
    // Name of the program.
    std::string PROGRAM_NAME = "Fitting Directed S1";
    // Description of the program.
    std::string PROGRAM_DESCRIPTION = "Fits the parameters of the directed S1 model to real networks";
    // Version of the code.
    std::string VERSION = "0.1";
    // Tab.
    std::string TAB = "    ";
    // Indices for in and out degree.
    const size_t in__deg_idx = 0;
    const size_t out_deg_idx = 1;
    // const size_t und_deg_idx = 2;

  // General internal objects.
  private:
    // Random number generator
    std::mt19937 engine;
    std::uniform_real_distribution<double> uniform_01;
    // std::normal_distribution<double> normal_01;
    // Objects mapping the name and the numerical ID of vertices.
    std::map< std::string, size_t > Name2Num;
    // std::vector<std::string> Num2Name;
    // // List of degree classes.
    // std::vector< std::set<int> > degree_class;
    // Cumulative probability used for the calculation of clustering using MC integration.
    std::map< int, std::map< int, std::map< double, std::pair<size_t, size_t>, std::less<double> > > > cumul_prob_kgkp;
    std::map< size_t, std::map< size_t, size_t > > degree_class;
    // // List containing the order in which the vertices will be considered in the maximization phase.
    // std::vector<int> ordered_list_of_vertices;
    // Time stamps.
    double time0, time1, time2, time3, time4, time5, time6, time7;
    time_t time_started, time_ended;
    // Stream used to output the log to file.
    std::ofstream logfile;
    std::streambuf *old_rdbuf;
    // Widths of the columns in output file.
    int width_names;
    int width_values;

  // Objects related to the original graph.
  private:
    // Number of vertices.
    int nb_vertices;
    int nb_vertices_undir_degree_gt_one;
    // Number of edges.
    int nb_edges;
    // Average degree.
    double average_degree;
    int nb_reciprocal_edges;
    int nb_triangles;
    double reciprocity;
    // Average local clustering coefficient.
    double average_undir_clustering;
    // // Average degree of neighbors.
    // std::vector<double> sum_degree_of_neighbors;
    // // Local clustering.
    // std::vector<double> nbtriangles;
    // // Adjacency list.
    // std::vector< std::vector< std::set<int> > > adjacency_list;
    // Degree.
    std::vector< std::vector<size_t> > degree;
    // ID of vertices in each degree class.
    // std::vector< std::map<int, std::vector<int> > > degree2vertices;
    std::vector< std::map<size_t, size_t> > degree_histogram;
    std::map< std::pair<size_t, size_t>, size_t> degreeHistogram;

  // Objects related to the inferred graph ensemble.
  public:
    // Parameter beta (clustering).
    double beta;
    // Parameter mu (average degree).
    double mu;
    double nu;
    double R;
  private:
    // Average degree of the inferred ensemble.
    double random_ensemble_average_degree;
    // Average local clustering coefficient of the inferred ensemble.
    double random_ensemble_average_clustering;
    double random_ensemble_reciprocity;
    // Maps containing the expected degree of each degree class.
    std::vector< std::map<int, double> > random_ensemble_expected_degree_per_degree_class;
    // // Expected degrees in the inferred ensemble (analytical, no finite-size effect).
    // std::vector<double> inferred_ensemble_expected_degree;
    // List of kappas by degree class.
    std::vector< std::map<int, double> > random_ensemble_kappa_per_degree_class;
    // // Hidden variables of the vertices.
    // std::vector<double> kappa;
    // // Positions of the vertices.
    // std::vector<double> theta;
    // sinus and cosinus of theta.
    // std::vector<double> sin_theta;
    // std::vector<double> cos_theta;

  // // Objects related to the characterization of the inferred ensemble (by simulations).
  // private:
  //   // Simulated adjacency list.
  //   std::vector< std::set<int> > simulated_adjacency_list;
  //   // Simulated degrees (one instance).
  //   std::vector<double> simulated_degree;
  //   // Simulated average degree of neighbors (one instance).
  //   std::vector<double> simulated_sum_degree_of_neighbors;
  //   // Simulated clustering coefficients (one instance).
  //   std::vector<double> simulated_nb_triangles;
  //   // Simulated degree distribution (one instance).
  //   std::map<int, double> simulated_stat_degree;
  //   // Simulated average sum of degree of neighbors by degree class.
  //   std::map<int, double> simulated_stat_sum_degree_neighbors;
  //   // Simulated average average degree of neighbors by degree class.
  //   std::map<int, double> simulated_stat_avg_degree_neighbors;
  //   // Simulated average number of triangles gathered by degree class.
  //   std::map<int, double> simulated_stat_nb_triangles;
  //   // Simulated average clustering coefficient by degree class.
  //   std::map<int, double> simulated_stat_clustering;
  //   // Characterization of vertices (all instances).
  //   std::vector< std::vector< std::vector<double> > > characterizing_inferred_ensemble_vprops;
  //   // Vertices statistics characterization (all instances).
  //   std::map< int, std::vector<double> > characterizing_inferred_ensemble_vstat;

  // Internal functions.
  private:
    // // === Initialization ===
    // // Extracts all relevant information about the degrees.
    // void analyze_degrees();
    // // Computes the average local clustering coefficient.
    // void count_undirected_triangles();
    // void compute_reciprocity();
    // // Loads the graph from an edgelist in a file.
    // void load_edgelist();
    // // Loads the already inferred parameters.
    // void load_already_inferred_parameters();
    // === Infering parameters ===
    // Builds the cumulative distribution to choose degree classes in the calculation of clustering.
    void build_cumul_dist_for_mc_integration();
    // Computes various properties of the random ensemble (before finding optimal positions).
    void compute_random_ensemble_average_degree();
    void compute_random_ensemble_clustering();
    double compute_random_ensemble_clustering_for_degree_class(std::pair <size_t, size_t> p);
    // Infers the values of kappa.
    // void infer_kappas_given_beta_for_all_vertices();
    void infer_kappas();
    void infer_nu();
    // === Connection probabilities ===
    double directed_connection_probability(double z, double koutkin);
    double undirected_connection_probability(double z, double kout1kin2, double kout2kin1);
    double find_minimal_angle_by_bisection(double kout1kin2, double kout2kin1);
    // === Embedding ===
    // Computes the log-likelihood between two vertices.
    // // double compute_pairwise_loglikelihood(int v1, double t1, int v2, double t2);
    // double compute_pairwise_loglikelihood(int v1, double t1, int v2, double t2, bool neighbors);
    // // Finds the initial ordering of vertices based on the Eigen Map method.
    // void find_initial_ordering(std::vector<int> &ordering, std::vector<double> &raw_theta);
    // void infer_initial_positions();
    // // Maximizes the log-likelihood by moving the vertices.
    // // double find_optimal_angle(int v1);
    // // double find_approximate_optimal_angle(int v1);
    // void refine_positions();
    // int refine_angle(int v1);
    // // void refine_angle2(int v1);
    // // void refine_angle3(int v1);
    // // void refine_angle4(int v1);
    // // void refine_angle5(int v1);
    // // void infer_optimal_positions();
    void finalize();
    // Loads the network and computes topological properties.
    void initialize();
    // Infers the parameters (kappas, beta) prior to the embedding.
    void infer_parameters();
    // // Extracts the onion decomposition (OD) of the graph and orders the vertices according to it.
    // void order_vertices();
    // // Updates the value of the expected degrees given the inferred positions of theta.
    // void compute_inferred_ensemble_expected_degrees();
    // // === Characterization of the inferred ensemble using simulations ===
    // void analyze_simulated_adjacency_list();
    // void generate_simulated_adjacency_list();
    // // === Miscellaneous ===
    // // Extracts the onion decomposition.
    // void extract_onion_decomposition(std::vector<int> &coreness, std::vector<int> &od_layer);
    // Gets and format current date/time.
    std::string format_time(time_t _time);
    // // Gets the time since epoch in seconds with decimals.
    // double time_since_epoch_in_seconds();
    // // === Output ===
    // // Writes the inferred connection probability into a file.
    // void save_inferred_connection_probability();
    // // Writes the inferred properties of vertices into a file.
    // void save_inferred_ensemble_characterization();
    // // Writes the inferred theta density into a file.
    // void save_inferred_theta_density();
    // Writes the inferred info into a file.
    void save_inferred_parameters();
    // // Function associated to the extraction of the components.
    // int get_root(int i, std::vector<int> &clust_id);
    // void merge_clusters(std::vector<int> &size, std::vector<int> &clust_id);
    // void check_connected_components();

  // Public functions to perform the embeddings.
  public:
    // Constructor (empty).
    fitting_directedS1_t() {};
    // Destructor (empty).
    ~fitting_directedS1_t() {};
    // Performs the embedding.
    void fit();
    void fit(std::string edgelist_filename) { EDGELIST_FILENAME = edgelist_filename; fit(); };
};





// =~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=
// =~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=
void fitting_directedS1_t::build_cumul_dist_for_mc_integration() {

  double tmp_val, tmp_cumul;
  double kout1, k_in1, kout2, k_in2;
  std::map< size_t, std::map< size_t, double > > nkkp;

  cumul_prob_kgkp.clear();
  for(auto in__el1: degree_class) {

    if(cumul_prob_kgkp.count(in__el1.first) == 0)
      cumul_prob_kgkp[in__el1.first];

    for(auto out_el1: in__el1.second) {

      // Initialization
      if(in__el1.second.count(out_el1.first) == 0)
        cumul_prob_kgkp[in__el1.first][out_el1.first];

      nkkp.clear();
      for(auto in__el2: degree_class)
        for(auto out_el2: in__el2.second)
          nkkp[in__el2.first][out_el2.first] = 0;

      // Filling up the distribution.
      tmp_cumul = 0;
      k_in1 = random_ensemble_kappa_per_degree_class[in__deg_idx][in__el1.first];
      kout1 = random_ensemble_kappa_per_degree_class[out_deg_idx][out_el1.first];
      for(auto in__el2: degree_class) {
        for(auto out_el2: in__el2.second) {
          k_in2 = random_ensemble_kappa_per_degree_class[in__deg_idx][in__el2.first];
          kout2 = random_ensemble_kappa_per_degree_class[out_deg_idx][out_el2.first];
          tmp_val = undirected_connection_probability(PI, kout1 * k_in2, kout2 * k_in1);
          // std::cout << tmp_val << std::endl;
          if((in__el1.first == in__el2.first) && (out_el1.first == out_el2.first))
            nkkp[in__el2.first][out_el2.first] = (out_el2.second - 1) * tmp_val;
          else
            nkkp[in__el2.first][out_el2.first] = out_el2.second  * tmp_val;
          tmp_cumul += nkkp[in__el2.first][out_el2.first];
        }
        // std::cout << std::endl;
      }

      // Normalization of the distribution.
      for(auto in__el2: nkkp)
        for(auto out_el2: in__el2.second)
          nkkp[in__el2.first][out_el2.first] = nkkp[in__el2.first][out_el2.first] / tmp_cumul;

      // Building the cumulative distribution.
      tmp_cumul = 0;
      for(auto in__el2: nkkp)
        for(auto out_el2: in__el2.second) {
          tmp_val = out_el2.second;
          // std::cout << tmp_val << std::endl;
          if(tmp_val > NUMERICAL_ZERO) {
            tmp_cumul += tmp_val;
            cumul_prob_kgkp[in__el1.first][out_el1.first][tmp_cumul] = std::make_pair(in__el2.first, out_el2.first);
            // std::cout << tmp_cumul << std::endl;
          }
        }
      // std::cout << std::endl;
    }
  }
}


// =~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=
// =~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=
void fitting_directedS1_t::compute_random_ensemble_average_degree() {
  random_ensemble_average_degree = 0;
  std::vector<size_t> directions = {in__deg_idx, out_deg_idx};
  for(auto direction: directions)
    for(auto el: degree_histogram[direction])
      random_ensemble_average_degree += el.second * random_ensemble_expected_degree_per_degree_class[direction][el.first];
  random_ensemble_average_degree /= nb_vertices * 2.;
}


// =~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=
// =~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=
void fitting_directedS1_t::compute_random_ensemble_clustering() {
  double tmp_val;
  random_ensemble_average_clustering = 0;
  for(const auto & in__el: degree_class) {
   for(auto out_el: in__el.second) {
      if(in__el.first + out_el.first > 1) {
        tmp_val = compute_random_ensemble_clustering_for_degree_class(std::make_pair(in__el.first, out_el.first));
        random_ensemble_average_clustering += tmp_val * out_el.second;
      }
    }
  }
  // random_ensemble_average_clustering /= nb_vertices;
  random_ensemble_average_clustering /= nb_vertices_undir_degree_gt_one;
}


// =~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=
// =~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=
double fitting_directedS1_t::compute_random_ensemble_clustering_for_degree_class(std::pair<size_t, size_t> p1)  {
  // Variables.
  std::pair<size_t, size_t> p2, p3;
  double p12, p13, p23, p32, pc, pz, zmin, zmax, z, z12, z13, da, tmp, k_in2, kout2, k_in3, kout3;
  double tmp_val = 0;
  double tmp_cumul = 0;
  double k_in1 = random_ensemble_kappa_per_degree_class[in__deg_idx][p1.first];
  double kout1 = random_ensemble_kappa_per_degree_class[out_deg_idx][p1.second];
  // Parameters.
  int nb_points = EXP_CLUST_NB_INTEGRATION_MC_STEPS;
  // MC integration.
  for(int i(0); i<nb_points; ++i) {
    // auto dummy = cumul_prob_kgkp[p1.first][p1.second].lower_bound(uniform_01(engine));
    // p2 = dummy->second;
    p2 = cumul_prob_kgkp[p1.first][p1.second].lower_bound(uniform_01(engine))->second;
    // std::cout << dummy->first << std::endl;
    k_in2 = random_ensemble_kappa_per_degree_class[in__deg_idx][p2.first];
    kout2 = random_ensemble_kappa_per_degree_class[out_deg_idx][p2.second];
    p12 = undirected_connection_probability(PI, kout1 * k_in2, kout2 * k_in1);

    pc = uniform_01(engine);
    zmin = 0;
    zmax = PI;
    while( (zmax - zmin) > NUMERICAL_CONVERGENCE_THRESHOLD_2 ) {
      z = (zmax + zmin) / 2;
      pz = undirected_connection_probability(z, kout1 * k_in2, kout2 * k_in1) / p12;
      if(pz > pc)
        zmax = z;
      else
        zmin = z;
    }
    z12 = (zmax + zmin) / 2;

    // dummy = cumul_prob_kgkp[p1.first][p1.second].lower_bound(uniform_01(engine));
    // p3 = dummy->second;
    p3 = cumul_prob_kgkp[p1.first][p1.second].lower_bound(uniform_01(engine))->second;
    // std::cout << dummy->first << std::endl;
    k_in3 = random_ensemble_kappa_per_degree_class[in__deg_idx][p3.first];
    kout3 = random_ensemble_kappa_per_degree_class[out_deg_idx][p3.second];
    p13 = undirected_connection_probability(PI, kout1 * k_in3, kout3 * k_in1);

    pc = uniform_01(engine);
    zmin = 0;
    zmax = PI;
    while( (zmax - zmin) > NUMERICAL_CONVERGENCE_THRESHOLD_2 ) {
      z = (zmax + zmin) / 2;
      pz = undirected_connection_probability(z, kout1 * k_in3, kout3 * k_in1) / p13;
      if(pz > pc)
        zmax = z;
      else
        zmin = z;
    }
    z13 = (zmax + zmin) / 2;


    if(uniform_01(engine) < 0.5)
      da = std::fabs(z12 + z13);
    else
      da = std::fabs(z12 - z13);
    da = std::min(da, (2.0 * PI) - da);
    // std::cout << da << std::endl;
    tmp_val = 0;
    if(da < NUMERICAL_ZERO)
      tmp_val += 1;
    else {
      p23 = 1.0 / (1.0 + std::pow((da * R) / (mu * kout2 * k_in3), beta));
      p32 = 1.0 / (1.0 + std::pow((da * R) / (mu * kout3 * k_in2), beta));
      tmp_val += p23 + p32;
      tmp_val -= (1 - std::fabs(nu)) * p23 * p32;
      if(nu > 0) {
        if(p23 < p32)
          tmp_val -= nu * p23;
        else
          tmp_val -= nu * p32;
      }
      if(nu < 0)
        if((p23 + p32) > 1)
          tmp_val -= nu * (1 - p23 - p32);
    }
    tmp_cumul += tmp_val;
    // std::cout << p1.first << " " << p1.second << " " << p2.first << " " << p2.second << " " << p3.first << " " << p3.second << " " << tmp_val << std::endl;
  }
  // Returns the value of the local clustering coefficient for this degree class.
  // std::cout << tmp_cumul / nb_points << std::endl;
  // std::cout << std::endl;
  return tmp_cumul / nb_points;
}


// =~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=
// =~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=
double fitting_directedS1_t::directed_connection_probability(double z, double koutkin)
{
  if(koutkin > NUMERICAL_ZERO)
    return (z / PI) * hyp2f1a(beta, -std::pow( (R * z) / (mu * koutkin), beta));
  else
    return 0;
}


// =~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=
// =~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=
double fitting_directedS1_t::undirected_connection_probability(double z, double kout1kin2, double kout2kin1)
{
  double p12 = directed_connection_probability(z, kout1kin2);
  double p21 = directed_connection_probability(z, kout2kin1);

  // Integral of p12p21
  double conn_prob = 0;
  if(std::fabs(kout1kin2 - kout2kin1) < NUMERICAL_CONVERGENCE_THRESHOLD_2)
    conn_prob -= (1 - std::fabs(nu)) * hyp2f1c(beta, -std::pow( (R * PI) / (mu * kout1kin2), beta));
  else {
    conn_prob -= ((1 - std::fabs(nu)) / (1 - std::pow(kout1kin2 / kout2kin1, beta)));
    conn_prob *= (p12 - (std::pow(kout1kin2 / kout2kin1, beta) * p21));
  }

  // Integral of p12
  conn_prob += p12;
  // Integral of p21
  conn_prob += p21;

  // Integral that depends on nu
  if(nu > 0) {
    // Integral of min(p12,p21)
    if(kout1kin2 < kout2kin1)
      conn_prob -= nu * p12;
    else
      conn_prob -= nu * p21;
  }
  else if(nu < 0) {
    // Integral with step function
    double z_max = find_minimal_angle_by_bisection(kout1kin2, kout2kin1);
    if(z_max < z)
    {
      p12 = directed_connection_probability(z_max, kout1kin2);
      p21 = directed_connection_probability(z_max, kout2kin1);
      conn_prob -= nu * ((z_max / PI) - p12 - p21);
    }
    else
      conn_prob -= nu * ((z / PI) - p12 - p21);
  }
  return conn_prob;
}


// =~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=
// =~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=
double fitting_directedS1_t::find_minimal_angle_by_bisection(double kout1kin2, double kout2kin1)
{
  double z_min = 0;
  double z_max = PI;
  double z_mid;
  double the_function_at_z_min;
  double the_function_at_z_mid;
  double the_function_at_z_max;
  while((z_max-z_min) > NUMERICAL_CONVERGENCE_THRESHOLD_2) {
    the_function_at_z_min = -1;
    the_function_at_z_min += 1 / (1 + std::pow( (R * z_min) / (mu * kout2kin1), beta));
    the_function_at_z_min += 1 / (1 + std::pow( (R * z_min) / (mu * kout1kin2), beta));

    z_mid = (z_min + z_max) / 2;
    the_function_at_z_mid = -1;
    the_function_at_z_mid += 1 / (1 + std::pow( (R * z_mid) / (mu * kout2kin1), beta));
    the_function_at_z_mid += 1 / (1 + std::pow( (R * z_mid) / (mu * kout1kin2), beta));

    the_function_at_z_max = -1;
    the_function_at_z_max += 1 / (1 + std::pow( (R * z_max) / (mu * kout2kin1), beta));
    the_function_at_z_max += 1 / (1 + std::pow( (R * z_max) / (mu * kout1kin2), beta));

    if((the_function_at_z_min * the_function_at_z_mid) > 0)
      z_min = z_mid;
    else if((the_function_at_z_max * the_function_at_z_mid) > 0)
      z_max = z_mid;
    else {
      z_min = PI;
      z_max = PI;
    }
  }
  return (z_min + z_max) / 2;
}


// =~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=
// =~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=
void fitting_directedS1_t::fit()
{
  // // Gets current time.
  // time0 = time_since_epoch_in_seconds();
  time_started = std::time(NULL);
  // Initialization.
  initialize();
  // // Gets current time.
  // time1 = time_since_epoch_in_seconds();
  // if(!REFINE_MODE)
  // {
    // Pre-processing: infers the parameters used for the embedding.
    infer_parameters();
  // }
//   // Gets current time.
//   time2 = time_since_epoch_in_seconds();
//   // Gets current time.
//   time3 = time_since_epoch_in_seconds();
//   // Gets current time.
//   time4 = time_since_epoch_in_seconds();
//   // Gets the current time.
//   time5 = time_since_epoch_in_seconds();
  time_ended = std::time(NULL);
  // Saves the inferred coordinates in a file.
  save_inferred_parameters();
//   // Gets the current time.
//   time6 = time_since_epoch_in_seconds();
//   // Gets the current time.
//   time7 = time_since_epoch_in_seconds();
//   time_ended = std::time(NULL);
  //
  finalize();
}


// =~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=
// =~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=
void fitting_directedS1_t::finalize()
{
  // Resets the formating of std::clog.
  std::clog << std::resetiosflags(std::ios::floatfield | std::ios::fixed | std::ios::showpoint);
//   // Writes the parameters used in the log for reproductibility.
  if(!QUIET_MODE) { std::clog << std::endl; }
  if(!QUIET_MODE) { std::clog << "Internal parameters and options"                                                                          << std::endl; }
//   if(!QUIET_MODE) { std::clog << TAB << "ALREADY_INFERRED_PARAMETERS_FILENAME   " << ALREADY_INFERRED_PARAMETERS_FILENAME                   << std::endl; }
  if(!QUIET_MODE) { std::clog << TAB << "BETA_ABS_MAX                           " << BETA_ABS_MAX                                           << std::endl; }
  if(!QUIET_MODE) { std::clog << TAB << "BETA_ABS_MIN                           " << BETA_ABS_MIN                                           << std::endl; }
//   if(!QUIET_MODE) { std::clog << TAB << "CHARACTERIZATION_MODE                  " << (CHARACTERIZATION_MODE       ? "true" : "false")       << std::endl; }
//   if(!QUIET_MODE) { std::clog << TAB << "CHARACTERIZATION_NB_GRAPHS             " << CHARACTERIZATION_NB_GRAPHS                             << std::endl; }
  if(!QUIET_MODE) { std::clog << TAB << "CLEAN_RAW_OUTPUT_MODE                  " << (CLEAN_RAW_OUTPUT_MODE       ? "true" : "false")       << std::endl; }
//   // if(!QUIET_MODE) { std::clog << TAB << "CLOSE_ANGULAR_RANGE_FACTOR             " << CLOSE_ANGULAR_RANGE_FACTOR                             << std::endl; }
  if(!QUIET_MODE) { std::clog << TAB << "CUSTOM_BETA                            " << (CUSTOM_BETA                 ? "true" : "false")       << std::endl; }
  if(!QUIET_MODE) { std::clog << TAB << "CUSTOM_MU                              " << (CUSTOM_MU                   ? "true" : "false")       << std::endl; }
  if(!QUIET_MODE) { std::clog << TAB << "CUSTOM_NU                              " << (CUSTOM_NU                   ? "true" : "false")       << std::endl; }
//   if(!QUIET_MODE) { std::clog << TAB << "CUSTOM_CHARACTERIZATION_NB_GRAPHS      " << (CUSTOM_CHARACTERIZATION_NB_GRAPHS ? "true" : "false") << std::endl; }
//   if(!QUIET_MODE) { std::clog << TAB << "CUSTOM_INFERRED_COORDINATES            " << (CUSTOM_INFERRED_COORDINATES ? "true" : "false")       << std::endl; }
  if(!QUIET_MODE) { std::clog << TAB << "CUSTOM_OUTPUT_ROOTNAME_MODE            " << (CUSTOM_OUTPUT_ROOTNAME_MODE ? "true" : "false")       << std::endl; }
  if(!QUIET_MODE) { std::clog << TAB << "CUSTOM_SEED                            " << (CUSTOM_SEED                 ? "true" : "false")       << std::endl; }
  if(!QUIET_MODE) { std::clog << TAB << "EDGELIST_FILENAME:                     " << EDGELIST_FILENAME                                      << std::endl; }
  if(!QUIET_MODE) { std::clog << TAB << "EXP_CLUST_NB_INTEGRATION_MC_STEPS      " << EXP_CLUST_NB_INTEGRATION_MC_STEPS                      << std::endl; }
//   if(!QUIET_MODE) { std::clog << TAB << "EXP_DIST_NB_INTEGRATION_STEPS          " << EXP_DIST_NB_INTEGRATION_STEPS                          << std::endl; }
  if(!QUIET_MODE) { std::clog << TAB << "KAPPA_MAX_NB_ITER_CONV                 " << KAPPA_MAX_NB_ITER_CONV                                 << std::endl; }
//   if(!QUIET_MODE) { std::clog << TAB << "KAPPA_POST_INFERENCE_MODE              " << (KAPPA_POST_INFERENCE_MODE   ? "true" : "false")       << std::endl; }
//   // if(!QUIET_MODE) { std::clog << TAB << "LIMIT_FOR_CONVERGENCE_CRITERION        " << LIMIT_FOR_CONVERGENCE_CRITERION                        << std::endl; }
//   // if(!QUIET_MODE) { std::clog << TAB << "MAX_NB_ITER_MAXIMIZATION               " << MAX_NB_ITER_MAXIMIZATION                               << std::endl; }
//   if(!QUIET_MODE) { std::clog << TAB << "MAXIMIZATION_MODE                      " << (MAXIMIZATION_MODE           ? "true" : "false")       << std::endl; }
//   // if(!QUIET_MODE) { std::clog << TAB << "MINIMAL_ANGULAR_CONVERGENCE_THRESHOLD  " << MINIMAL_ANGULAR_CONVERGENCE_THRESHOLD                  << std::endl; }
//   // if(!QUIET_MODE) { std::clog << TAB << "MINIMAL_ANGULAR_RESOLUTION             " << MINIMAL_ANGULAR_RESOLUTION                             << std::endl; }
//   // if(!QUIET_MODE) { std::clog << TAB << "NB_VERTICES_IN_CORE                    " << NB_VERTICES_IN_CORE                                    << std::endl; }
//   if(!QUIET_MODE) { std::clog << TAB << "MIN_NB_ANGLES_TO_TRY                   " << MIN_NB_ANGLES_TO_TRY                                   << std::endl; }
//   if(!QUIET_MODE) { std::clog << TAB << "NUMERICAL_CONVERGENCE_THRESHOLD_1      " << NUMERICAL_CONVERGENCE_THRESHOLD_1                      << std::endl; }
//   if(!QUIET_MODE) { std::clog << TAB << "NUMERICAL_CONVERGENCE_THRESHOLD_2      " << NUMERICAL_CONVERGENCE_THRESHOLD_2                      << std::endl; }
//   if(!QUIET_MODE) { std::clog << TAB << "NUMERICAL_CONVERGENCE_THRESHOLD_3      " << NUMERICAL_CONVERGENCE_THRESHOLD_3                      << std::endl; }
  if(!QUIET_MODE) { std::clog << TAB << "NUMERICAL_ZERO                         " << NUMERICAL_ZERO                                         << std::endl; }
  if(!QUIET_MODE) { std::clog << TAB << "QUIET_MODE                             " << (QUIET_MODE                  ? "true" : "false")       << std::endl; }
//   if(!QUIET_MODE) { std::clog << TAB << "REFINE_MODE                            " << (REFINE_MODE                 ? "true" : "false")       << std::endl; }
//   // if(!QUIET_MODE) { std::clog << TAB << "REFINED_MAX_STEP_LENGTH_DIVISOR        " << REFINED_MAX_STEP_LENGTH_DIVISOR                        << std::endl; }
  if(!QUIET_MODE) { std::clog << TAB << "ROOTNAME_OUTPUT:                       " << ROOTNAME_OUTPUT                                        << std::endl; }
  if(!QUIET_MODE) { std::clog << TAB << "SEED                                   " << SEED                                                   << std::endl; }
//   if(!QUIET_MODE) { std::clog << TAB << "VALIDATION_MODE                        " << (VALIDATION_MODE             ? "true" : "false")       << std::endl; }
  if(!QUIET_MODE) { std::clog << TAB << "VERBOSE_MODE                           " << (VERBOSE_MODE                ? "true" : "false")       << std::endl; }
  if(!QUIET_MODE) { std::clog << TAB << "VERSION                                " << VERSION                                                << std::endl; }
//   if(!QUIET_MODE) { std::clog                                                                                                               << std::endl; }
//   if(!QUIET_MODE) { std::clog << "Ended on: "                                     << format_time(time_ended)                                << std::endl; }
//   if(!QUIET_MODE) { std::clog << "Elapsed CPU time (embedding):            "          << std::setw(10) << std::fixed << time5 - time0 << " seconds"     << std::endl; }
//   if(!QUIET_MODE) { std::clog << TAB << "initialization:                      "       << std::setw(10) << std::fixed << time1 - time0 << " seconds"     << std::endl; }
//   if(!REFINE_MODE)
//     if(!QUIET_MODE) { std::clog << TAB << "parameters inference:                "     << std::setw(10) << std::fixed << time2 - time1 << " seconds"     << std::endl; }
//   if(!REFINE_MODE)
//     if(!QUIET_MODE) { std::clog << TAB << "initial positions:                   "     << std::setw(10) << std::fixed << time3 - time2 << " seconds"     << std::endl; }
//   if(REFINE_MODE)
//     if(!QUIET_MODE) { std::clog << TAB << "loading previous positions:          "     << std::setw(10) << std::fixed << time3 - time1 << " seconds"     << std::endl; }
//   if(MAXIMIZATION_MODE)
//     if(!QUIET_MODE) { std::clog << TAB << "refining positions:                  "     << std::setw(10) << std::fixed << time4 - time3 << " seconds"     << std::endl; }
//   if(!QUIET_MODE) { std::clog << TAB << "adjusting kappas:                    "       << std::setw(10) << std::fixed << time5 - time4 << " seconds"     << std::endl; }
//   if(VALIDATION_MODE || CHARACTERIZATION_MODE)
//     if(!QUIET_MODE) { std::clog << "Elapsed CPU time (validation):           "        << std::setw(10) << std::fixed << time7 - time5 << " seconds"     << std::endl; }
//   if(VALIDATION_MODE)
//     if(!QUIET_MODE) { std::clog << TAB << "validating embedding:                "     << std::setw(10) << std::fixed << time6 - time5 << " seconds"     << std::endl; }
//   if(CHARACTERIZATION_MODE)
//     if(!QUIET_MODE) { std::clog << TAB << "characterizing ensemble:             "     << std::setw(10) << std::fixed << time7 - time6 << " seconds"     << std::endl; }
  if(!QUIET_MODE) { std::clog << "==========================================================================================="        << std::endl; }
  // Puts the streams back into place (to avoid a segmentation fault when exiting program).
  if(!QUIET_MODE)
  {
    if(!VERBOSE_MODE)
    {
      logfile.close();
      // Reset the rdbuf of clog.
      std::clog.rdbuf(old_rdbuf);
    }
  }
}


// =~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=
// =~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=
std::string fitting_directedS1_t::format_time(time_t _time)
{
  // Gets the current date/time.
  struct tm *aTime = gmtime(& _time);
  int year    = aTime->tm_year + 1900;
  int month   = aTime->tm_mon + 1;
  int day     = aTime->tm_mday;
  int hours   = aTime->tm_hour;
  int minutes = aTime->tm_min;
  // Format the string.
  std::string the_time = std::to_string(year) + "/";
  if(month < 10)
    the_time += "0";
  the_time += std::to_string(month) + "/";
  if(day < 10)
    the_time += "0";
  the_time += std::to_string(day) + " " + std::to_string(hours) + ":";
  if(minutes < 10)
    the_time += "0";
  the_time += std::to_string(minutes) + " UTC";
  // Returns the date/time.
  return the_time;
}


// =~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=
// =~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=
void fitting_directedS1_t::infer_kappas() {
  // Initializes the kappas for each degree class.
  random_ensemble_kappa_per_degree_class.resize(2);
  random_ensemble_expected_degree_per_degree_class.resize(2);
  std::vector<size_t> directions = {in__deg_idx, out_deg_idx};
  for(auto direction: directions)
    for(auto el: degree_histogram[direction])
      random_ensemble_kappa_per_degree_class[direction][el.first] = el.first + 0.001;

  // Finds the values of kappa generating the degree classes, given the parameters.
  double prob_conn;
  int cnt = 0;
  bool keep_going = true;
  double k_in1, kout1, k_in2, kout2;
  size_t d_in1, dout1, d_in2, dout2;
  while( keep_going && (cnt < KAPPA_MAX_NB_ITER_CONV) ) {
    // Initializes the expected degree of each degree class.
    for(auto direction: directions)
      for(auto el: degree_histogram[direction])
        random_ensemble_expected_degree_per_degree_class[direction][el.first] = 0;
    // Computes the expected degrees given the actual kappas.
    for(auto in__el: degree_histogram[in__deg_idx]) {
      for(auto out_el: degree_histogram[out_deg_idx]) {
        prob_conn = directed_connection_probability(PI, random_ensemble_kappa_per_degree_class[out_deg_idx][out_el.first] * random_ensemble_kappa_per_degree_class[in__deg_idx][in__el.first]);
        random_ensemble_expected_degree_per_degree_class[in__deg_idx][in__el.first] += prob_conn * out_el.second;
        random_ensemble_expected_degree_per_degree_class[out_deg_idx][out_el.first] += prob_conn * in__el.second;
      }
    }

    // for(const auto& el1: degreeHistogram) {
    //   dout1 = el1.first.second;
    //   kout1 = random_ensemble_kappa_per_degree_class[out_deg_idx][dout1];
    //   for(const auto& el2: degreeHistogram) {
    //     d_in2 = el2.first.first;
    //     k_in2 = random_ensemble_kappa_per_degree_class[in__deg_idx][d_in2];
    //     prob_conn = directed_connection_probability(PI, kout1 * k_in2);
    //     if(el1.first == el2.first) {
    //       random_ensemble_expected_degree_per_degree_class[in__deg_idx][d_in2] += (el1.second - 1) * prob_conn;
    //       random_ensemble_expected_degree_per_degree_class[out_deg_idx][dout1] += (el2.second - 1) * prob_conn;
    //     }
    //     else {
    //       random_ensemble_expected_degree_per_degree_class[in__deg_idx][d_in2] += el1.second * prob_conn;
    //       random_ensemble_expected_degree_per_degree_class[out_deg_idx][dout1] += el2.second * prob_conn;
    //     }
    //   }
    // }

    // for(int v1(0); v1<nb_vertices; ++v1) {
    //   d_in1 = degree[in__deg_idx][v1];
    //   dout1 = degree[out_deg_idx][v1];
    //   k_in1 = random_ensemble_kappa_per_degree_class[in__deg_idx][d_in1];
    //   kout1 = random_ensemble_kappa_per_degree_class[out_deg_idx][dout1];
    //   for(int v2(v1 + 1); v2<nb_vertices; ++v2) {
    //     d_in2 = degree[in__deg_idx][v2];
    //     dout2 = degree[out_deg_idx][v2];
    //     k_in2 = random_ensemble_kappa_per_degree_class[in__deg_idx][d_in2];
    //     kout2 = random_ensemble_kappa_per_degree_class[out_deg_idx][dout2];
    //
    //     prob_conn = directed_connection_probability(PI, kout1 * k_in2);
    //     random_ensemble_expected_degree_per_degree_class[in__deg_idx][d_in2] += prob_conn / degree_histogram[in__deg_idx][d_in2];
    //     random_ensemble_expected_degree_per_degree_class[out_deg_idx][dout1] += prob_conn / degree_histogram[out_deg_idx][dout1];
    //
    //     prob_conn = directed_connection_probability(PI, kout2 * k_in1);
    //     random_ensemble_expected_degree_per_degree_class[in__deg_idx][d_in1] += prob_conn / degree_histogram[in__deg_idx][d_in1];
    //     random_ensemble_expected_degree_per_degree_class[out_deg_idx][dout2] += prob_conn / degree_histogram[out_deg_idx][dout2];
    //   }
    // }

    // Verifies convergence.
    keep_going = false;
    for(auto direction: directions)
      for(auto el: degree_histogram[direction])
        if(std::fabs(random_ensemble_expected_degree_per_degree_class[direction][el.first] - el.first) > NUMERICAL_CONVERGENCE_THRESHOLD_1)
          keep_going = true;
    // Modifies the value of the kappas prior to the next iteration, if required.
    if(keep_going) {
      for(auto direction: directions) {
        for(auto el: degree_histogram[direction]) {
          random_ensemble_kappa_per_degree_class[direction][el.first] += (el.first - random_ensemble_expected_degree_per_degree_class[direction][el.first]) * uniform_01(engine);
          if(random_ensemble_kappa_per_degree_class[direction][el.first] < 0)
            random_ensemble_kappa_per_degree_class[direction][el.first] = std::fabs(random_ensemble_kappa_per_degree_class[direction][el.first]);
          // if(std::isnan(random_ensemble_kappa_per_degree_class[direction][el.first]))
          //   std::cout << direction << "  " << el.first << std::endl;
        }
      }
      ++cnt;
    }
    // std::cout << std::endl << std::endl;

    if(cnt >= KAPPA_MAX_NB_ITER_CONV)
    {
      if(!QUIET_MODE) { std::clog << std::endl; }
      if(!QUIET_MODE) { std::clog << TAB << "WARNING: maximum number of iterations reached before convergence. This limit can be"  << std::endl; }
      if(!QUIET_MODE) { std::clog << TAB << "         adjusted through the parameter KAPPA_MAX_NB_ITER_CONV." << std::endl; }
      if(!QUIET_MODE) { std::clog << TAB; }
      if(!QUIET_MODE) { std::clog << std::fixed << std::setw(11) << " " << " "; }
    }
  }
}


// =~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=
// =~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=
void fitting_directedS1_t::infer_parameters() {

  if(!QUIET_MODE) { std::clog << "Inferring parameters..."; }
  if(!CUSTOM_BETA) {

    beta = 1 + uniform_01(engine);
    if(!CUSTOM_MU)
      mu = beta * std::sin(PI / beta) / (2.0 * PI * average_degree);
    R = nb_vertices / (2 * PI);

    if(!QUIET_MODE) { std::clog << std::endl << std::endl << TAB; }
    if(!QUIET_MODE) { std::clog << std::fixed << std::setw(15) << "beta"          << " "; }
    if(!QUIET_MODE) { std::clog << std::fixed << std::setw(15) << "avg.degree"    << " "; }
    if(!QUIET_MODE) { std::clog << std::fixed << std::setw(15) << "nu"            << " "; }
    if(!QUIET_MODE) { std::clog << std::fixed << std::setw(15) << "reciprocity"   << " "; }
    if(!QUIET_MODE) { std::clog << std::fixed << std::setw(15) << "avg.und.clust" << " "; }
    if(!QUIET_MODE) { std::clog << std::endl; }

    double beta_max = -1;
    double beta_min = 1;

    double random_ensemble_average_clustering_min;
    double random_ensemble_average_clustering_max;

    while( true ) {

      if(!QUIET_MODE) { std::clog << TAB; }
      if(!QUIET_MODE) { std::clog << std::fixed << std::setw(15) << beta << " "; }
      if(!QUIET_MODE) { std::clog.flush(); }

      infer_kappas();
      compute_random_ensemble_average_degree();
      if(!QUIET_MODE) { std::clog << std::fixed << std::setw(15) << random_ensemble_average_degree << " "; }
      if(!QUIET_MODE) { std::clog.flush(); }

      if(!CUSTOM_NU)
        infer_nu();
      if(!QUIET_MODE) { std::clog << std::fixed << std::setw(15) << nu << " "; }
      if(!QUIET_MODE) { std::clog << std::fixed << std::setw(15) << random_ensemble_reciprocity << " "; }
      if(!QUIET_MODE) { std::clog.flush(); }

      build_cumul_dist_for_mc_integration();
      compute_random_ensemble_clustering();
      if(!QUIET_MODE) { std::clog << std::fixed << std::setw(15) << random_ensemble_average_clustering << " "; }
      if(!QUIET_MODE) { std::clog << std::endl; }

      // Checks if the expected clustering is close enough.
      if( std::fabs(random_ensemble_average_clustering - average_undir_clustering) < NUMERICAL_CONVERGENCE_THRESHOLD_1 )
      {
        break;
      }

      // Modifies the bounds on beta if another iteration is required.
      if(random_ensemble_average_clustering > average_undir_clustering)
      {
        beta_max = beta;
        random_ensemble_average_clustering_max = random_ensemble_average_clustering;
        // beta = (beta_max + beta_min) / 2;
        if(beta_min == 1)
          beta = (beta_max + beta_min) / 2;
        else
          beta = beta_min + (beta_max - beta_min) * (average_undir_clustering - random_ensemble_average_clustering_min) / (random_ensemble_average_clustering_max - random_ensemble_average_clustering_min);
        if(beta < BETA_ABS_MIN)
        {
          if(!QUIET_MODE) { std::clog << "WARNING: value too close to 1, using beta = " << std::fixed << std::setw(15) << beta << "."; }
          if(!QUIET_MODE) { std::clog << std::endl; }
          break;
        }
      }
      else
      {
        beta_min = beta;
        random_ensemble_average_clustering_min = random_ensemble_average_clustering;
        if(beta_max == -1)
        {
          beta *= 1.5;
        }
        else
        {
          // beta = (beta_max + beta_min) / 2;
          beta = beta_min + (beta_max - beta_min) * (average_undir_clustering - random_ensemble_average_clustering_min) / (random_ensemble_average_clustering_max - random_ensemble_average_clustering_min);
        }
      }
      if(beta > BETA_ABS_MAX)
      {
        if(!QUIET_MODE) { std::clog << "WARNING: value too high, using beta = " << std::fixed << std::setw(11) << beta << "."; }
        if(!QUIET_MODE) { std::clog << std::endl; }
        break;
      }
    }
  }
  else {

    if(!CUSTOM_MU)
      mu = beta * std::sin(PI / beta) / (2.0 * PI * average_degree);
    R = nb_vertices / (2 * PI);
    infer_kappas();
    compute_random_ensemble_average_degree();
    if(!CUSTOM_NU)
      infer_nu();
    build_cumul_dist_for_mc_integration();
    compute_random_ensemble_clustering();
  }

  if(!CUSTOM_BETA) {
    if(!QUIET_MODE) { std::clog << "                       "; }
  }
  else {
    if(!QUIET_MODE) { std::clog << "...............................................................done."                                                       << std::endl; }
  }
  // if(!QUIET_MODE) { std::clog << std::endl; }

  if(!QUIET_MODE) { std::clog                                                                                                                                 << std::endl; }
  if(!QUIET_MODE) { std::clog << "Inferred parameters:"                                                                                                       << std::endl; }
  if(!CUSTOM_BETA) {
    if(!QUIET_MODE) { std::clog << TAB << "beta:                            " << beta                                                                         << std::endl; }
  }
  else {
    if(!QUIET_MODE) { std::clog << TAB << "beta:                            " << beta  << "        (custom)"                                                  << std::endl; }
  }
  if(!CUSTOM_MU) {
    if(!QUIET_MODE) { std::clog << TAB << "mu:                              " << mu                                                                           << std::endl; }
  }
  else {
    if(!QUIET_MODE) { std::clog << TAB << "mu:                              " << mu  << "        (custom)"                                                    << std::endl; }
  }
  if(!CUSTOM_NU) {
    if(!QUIET_MODE) { std::clog << TAB << "nu:                              " << nu                                                                           << std::endl; }
  }
  else {
    if(!QUIET_MODE) { std::clog << TAB << "nu:                              " << nu  << "        (custom)"                                                    << std::endl; }
  }
  if(!QUIET_MODE) { std::clog << TAB << "R:                               " << R                                                                              << std::endl; }
  if(!QUIET_MODE) { std::clog                                                                                                                                 << std::endl; }
  if(!QUIET_MODE) { std::clog << "Expected properties of the inferred ensemble:"                                                                              << std::endl; }
  if(!QUIET_MODE) { std::clog << TAB << "Average degree:                  " << random_ensemble_average_degree                                                 << std::endl; }
  // if(!QUIET_MODE) { std::clog << TAB << "Minimum in-degree:               " << random_ensemble_expected_degree_per_degree_class[in__deg_idx].begin()->first   << std::endl; }
  // if(!QUIET_MODE) { std::clog << TAB << "Minimum out-degree:              " << random_ensemble_expected_degree_per_degree_class[out_deg_idx].begin()->first   << std::endl; }
  // if(!QUIET_MODE) { std::clog << TAB << "Maximum in-degree:               " << (--random_ensemble_expected_degree_per_degree_class[in__deg_idx].end())->first << std::endl; }
  // if(!QUIET_MODE) { std::clog << TAB << "Maximum out-degree:              " << (--random_ensemble_expected_degree_per_degree_class[out_deg_idx].end())->first << std::endl; }
  if(!QUIET_MODE) { std::clog << TAB << "Average clustering:              " << random_ensemble_average_clustering                                             << std::endl; }
  if(!QUIET_MODE) { std::clog << TAB << "Reciprocity:                     " << random_ensemble_reciprocity                                                    << std::endl; }
  if(!QUIET_MODE) { std::clog                                                                                                                                 << std::endl; }
}


// =~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=
// =~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=
void fitting_directedS1_t::infer_nu()
{
  double xi_m1(0), xi_00(0), xi_p1(0);
  double p12, p21;
  double kout1kin2, kout2kin1;

  for(int v1(0); v1<nb_vertices; ++v1) {

    for(int v2(v1 + 1); v2<nb_vertices; ++v2) {

      kout1kin2 = random_ensemble_kappa_per_degree_class[out_deg_idx][degree[out_deg_idx][v1]] * random_ensemble_kappa_per_degree_class[in__deg_idx][degree[in__deg_idx][v2]];
      kout2kin1 = random_ensemble_kappa_per_degree_class[out_deg_idx][degree[out_deg_idx][v2]] * random_ensemble_kappa_per_degree_class[in__deg_idx][degree[in__deg_idx][v1]];

      p12 = directed_connection_probability(PI, kout1kin2);
      p21 = directed_connection_probability(PI, kout2kin1);

      // Integral of p12p21
      if(std::fabs(kout1kin2 - kout2kin1) < NUMERICAL_CONVERGENCE_THRESHOLD_2)
        xi_00 += hyp2f1c(beta, -std::pow( (R * PI) / (mu * kout1kin2), beta));
      else
        xi_00 += (1 / (1 - std::pow(kout1kin2 / kout2kin1, beta))) * (p12 - (std::pow(kout1kin2 / kout2kin1, beta) * p21));

      // Integral of min(p12,p21)
        if((kout1kin2) < (kout2kin1))
          xi_p1 += p12;
        else
          xi_p1 += p21;

      // Integral with step function
      double z_max = find_minimal_angle_by_bisection(kout1kin2, kout2kin1);
      if(z_max < PI) {
        p12 = directed_connection_probability(z_max, kout1kin2);
        p21 = directed_connection_probability(z_max, kout2kin1);
        xi_m1 += (z_max / PI) - p12 - p21;
      }
      else
        xi_m1 += 1 - p12 - p21;
    }
  }

  xi_m1 /= random_ensemble_average_degree * nb_vertices / 2;
  xi_00 /= random_ensemble_average_degree * nb_vertices / 2;
  xi_p1 /= random_ensemble_average_degree * nb_vertices / 2;

  if(reciprocity > xi_00)
    nu = (reciprocity - xi_00) / (xi_p1 - xi_00);
  else
    nu = (reciprocity - xi_00) / (xi_m1 + xi_00);

  if(nu > 1) {
    nu = 1;
    // if(!QUIET_MODE) { std::clog << std::endl; }
    // if(!QUIET_MODE) { std::clog << TAB << "WARNING: the level of reciprocity can only be obtained with nu > 1. Setting nu = 1."  << std::endl; }
    // if(!QUIET_MODE) { std::clog << TAB; }
    // if(!QUIET_MODE) { std::clog << std::fixed << std::setw(11) << " " << " "; }
  }

  if(nu < -1) {
    nu = -1;
    // if(!QUIET_MODE) { std::clog << std::endl; }
    // if(!QUIET_MODE) { std::clog << TAB << "WARNING: the level of reciprocity can only be obtained with nu < -1. Setting nu = -1."  << std::endl; }
    // if(!QUIET_MODE) { std::clog << TAB; }
    // if(!QUIET_MODE) { std::clog << std::fixed << std::setw(11) << " " << " "; }
  }

  if(nu > 0)
    random_ensemble_reciprocity = (xi_p1 - xi_00) * nu + xi_00;
  else
    random_ensemble_reciprocity = (xi_m1 + xi_00) * nu + xi_00;
}


// =~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=
// =~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=
void fitting_directedS1_t::initialize()
{
  // Sets the default rootname for output files.
  if(CUSTOM_OUTPUT_ROOTNAME_MODE == false)
  {
    size_t lastdot = EDGELIST_FILENAME.find_last_of("_");
    if(lastdot == std::string::npos)
    {
      ROOTNAME_OUTPUT = EDGELIST_FILENAME;
    }
    ROOTNAME_OUTPUT = EDGELIST_FILENAME.substr(0, lastdot);
  }
  // // Gets current time.
  // time0 = std::time(NULL);
  // Initializes the random number generator.
  if(!CUSTOM_SEED)
  {
    SEED = std::time(NULL);
  }
  engine.seed(SEED);
  // Change the stream std::clog to a file.
  if(!QUIET_MODE)
  {
    if(!VERBOSE_MODE)
    {
     logfile.open(ROOTNAME_OUTPUT + "_log.txt");
     // Get the rdbuf of clog.
     // We need it to reset the value before exiting.
     old_rdbuf = std::clog.rdbuf();
     // Set the rdbuf of clog.
     std::clog.rdbuf(logfile.rdbuf());
    }
  }
  // Outputs options and parameters on screen.
  if(!QUIET_MODE) { std::clog                                                                                                  << std::endl; }
  if(!QUIET_MODE) { std::clog << "===========================================================================================" << std::endl; }
  if(!QUIET_MODE) { std::clog << PROGRAM_NAME << ": " << PROGRAM_DESCRIPTION                                                   << std::endl; }
  if(!QUIET_MODE) { std::clog << "version: "           << VERSION                                                              << std::endl; }
  if(!QUIET_MODE) { std::clog << "started on: "        << format_time(time_started)                                            << std::endl; }
  if(!QUIET_MODE) { std::clog << "edgelist filename: " << EDGELIST_FILENAME                                                    << std::endl; }
  if(!QUIET_MODE) { std::clog << "seed: "              << SEED                                                                 << std::endl; }

  if(!QUIET_MODE) { std::clog                                                                                                  << std::endl; }
  if(!QUIET_MODE) { std::clog << "Loading the graph..."; }
  PGL::DirectedGraph theGraph;
  bool allow_multiedges = false;
  bool allow_selfloops = false;
  Name2Num = PGL::loadGraphFromEdgelist(EDGELIST_FILENAME, theGraph, allow_multiedges, allow_selfloops);
  nb_vertices = theGraph.getSize();
  nb_edges = theGraph.getEdgeNumber();
  if(!QUIET_MODE) { std::clog << "..................................................................done."                    << std::endl; }
//
//   if(!QUIET_MODE) { std::clog                                                                                                  << std::endl; }
//   if(!QUIET_MODE) { std::clog << "Checking number of connected components..."; }
//   check_connected_components();
//   if(!QUIET_MODE) { std::clog << "............................................done."                                           << std::endl; }
//
  if(!QUIET_MODE) { std::clog                                                                                                  << std::endl; }
  if(!QUIET_MODE) { std::clog << "Extracting degree histograms..."; }
  // analyze_degrees();
  degree.resize(2);
  degree[in__deg_idx] = theGraph.getInDegrees();
  degree[out_deg_idx] = theGraph.getOutDegrees();
  average_degree = std::accumulate(degree[in__deg_idx].begin(), degree[in__deg_idx].end(), 0.0) / nb_vertices;
  degree_histogram.resize(2);
  degree_histogram[in__deg_idx] = PGL::getInDegreeHistogram(theGraph, degree[in__deg_idx]);
  degree_histogram[out_deg_idx] = PGL::getOutDegreeHistogram(theGraph);
  nb_vertices_undir_degree_gt_one = 0;
  for(int v(0), kout, k_in; v<nb_vertices; ++v) {
    kout = degree[out_deg_idx][v];
    k_in = degree[in__deg_idx][v];
    if((k_in + kout) > 1)
      ++nb_vertices_undir_degree_gt_one;
  }
  degree_class.clear();
  for(int v(0), d_in, dout; v<nb_vertices;++v) {
    d_in = degree[in__deg_idx][v];
    dout = degree[out_deg_idx][v];
    if(degree_class.count(d_in) == 0)
      degree_class[d_in];
    if(degree_class[d_in].count(dout) == 0)
      degree_class[d_in][dout] = 1;
    else
      degree_class[d_in][dout] += 1;
  }
  degreeHistogram.clear();
  std::pair<size_t, size_t> degrees;
  for(int v(0); v<nb_vertices;++v) {
    degrees = std::make_pair(degree[in__deg_idx][v], degree[out_deg_idx][v]);
    if(degreeHistogram.count(degrees) == 0)
      degreeHistogram[degrees] = 1;
    else
      degreeHistogram[degrees] += 1;
  }
  if(!QUIET_MODE) { std::clog << ".......................................................done."                     << std::endl; }

  if(!QUIET_MODE) { std::clog                                                                                                  << std::endl; }
  if(!QUIET_MODE) { std::clog << "Computing average local undirected clustering coefficient..."; }
  auto localUndirectedCoefficients = PGL::getUndirectedLocalClusteringCoefficients(theGraph);
  // average_undir_clustering = std::accumulate(localUndirectedCoefficients.begin(), localUndirectedCoefficients.end(), 0.0) / nb_vertices;
  average_undir_clustering = std::accumulate(localUndirectedCoefficients.begin(), localUndirectedCoefficients.end(), 0.0) / nb_vertices_undir_degree_gt_one;
  if(!QUIET_MODE) { std::clog << "..........................done."                      << std::endl; }

  if(!QUIET_MODE) { std::clog                                                                                                  << std::endl; }
  if(!QUIET_MODE) { std::clog << "Computing reciprocity..."; }
  auto reciprocalDegrees = PGL::getReciprocalDegrees(theGraph);
  reciprocity = std::accumulate(reciprocalDegrees.begin(), reciprocalDegrees.end(), 0.0) / nb_edges;
  if(!QUIET_MODE) { std::clog << "..............................................................done."                         << std::endl; }

  // Sets the decimal precision of the log.
  std::clog.precision(4);

  // Sets the width of the columns in the output files.
  width_values = 15;
  width_names = 14;
  int l;
  for(auto el: Name2Num)
  {
    l = el.first.length();
    if(l > width_names)
    {
      width_names = l;
    }
  }
  width_names += 1;

  if(!QUIET_MODE) { std::clog                                                                                                  << std::endl; }
  if(!QUIET_MODE) { std::clog << "Properties of the original graph:"                                                           << std::endl; }
  if(!QUIET_MODE) { std::clog << TAB << "Nb vertices:                     " << nb_vertices                                     << std::endl; }
  if(!QUIET_MODE) { std::clog << TAB << "Nb edges:                        " << nb_edges                                        << std::endl; }
  if(!QUIET_MODE) { std::clog << TAB << "Average degree:                  " << average_degree                                  << std::endl; }
  if(!QUIET_MODE) { std::clog << TAB << "Minimum in-degree:               " << degree_histogram[in__deg_idx].begin()->first    << std::endl; }
  if(!QUIET_MODE) { std::clog << TAB << "Minimum out-degree:              " << degree_histogram[out_deg_idx].begin()->first    << std::endl; }
  if(!QUIET_MODE) { std::clog << TAB << "Maximum in-degree:               " << (--degree_histogram[in__deg_idx].end())->first  << std::endl; }
  if(!QUIET_MODE) { std::clog << TAB << "Maximum out-degree:              " << (--degree_histogram[out_deg_idx].end())->first  << std::endl; }
  if(!QUIET_MODE) { std::clog << TAB << "Nb of in-degree classes:         " << degree_histogram[in__deg_idx].size()            << std::endl; }
  if(!QUIET_MODE) { std::clog << TAB << "Nb of out-degree classes:        " << degree_histogram[out_deg_idx].size()            << std::endl; }
  if(!QUIET_MODE) { std::clog << TAB << "Avg. undir. local clust. coeff.: " << average_undir_clustering                        << std::endl; }
  if(!QUIET_MODE) { std::clog << TAB << "Reciprocity:                     " << reciprocity                                     << std::endl; }
  if(!QUIET_MODE) { std::clog                                                                                                  << std::endl; }
}


// =~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=
// =~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=
void fitting_directedS1_t::save_inferred_parameters()
{
//   // Finds the minimal and maximal values of kappa.
//   double kappa_min = *std::min_element(kappa.begin(), kappa.end());
//   double kappa_max = *std::max_element(kappa.begin(), kappa.end());
//   // Computes the hyperbolic radius (adjusts it in case some vertices have a negative radial position).
//   double hyp_radius = 2 * std::log( nb_vertices / (PI * mu * kappa_min * kappa_min) );
//   double min_radial_position = hyp_radius - 2 * std::log( kappa_min / kappa_max );
//   bool warning = false;
//   if(min_radial_position < 0)
//   {
//     hyp_radius += std::fabs(min_radial_position);
//     warning = true;
//   }
  // Sets the name of the file to write the hidden variables into.
  std::string coordinates_filename = ROOTNAME_OUTPUT + "_infparams.txt";
  // // Gets the current time.
  // time1 = std::time(NULL);
  // Opens the stream and terminates if the operation did not succeed.
  std::fstream coordinates_file(coordinates_filename.c_str(), std::fstream::out);
  if( !coordinates_file.is_open() )
  {
    std::cerr << "Could not open file: " << coordinates_filename << "." << std::endl;
    std::terminate();
  }
  // Writes the header.
  coordinates_file << "# =~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=" << std::endl;
  coordinates_file << "# Started at:                        " << format_time(time_started)                                                      << std::endl;
  // coordinates_file << "# Ended at:              " << format_time(time_ended)      << std::endl;
  // coordinates_file << "# Elapsed CPU time:      " << time5 - time0 << " seconds"  << std::endl;
  coordinates_file << "# Edgelist file:                     " << EDGELIST_FILENAME                                                              << std::endl;
  coordinates_file << "#"                                                                                                                       << std::endl;
  coordinates_file << "# Inferred parameters:"                                                                                                  << std::endl;
  coordinates_file << "#   N:                               " << nb_vertices                                                                    << std::endl;
  coordinates_file << "#   beta:                            " << beta                                                                           << std::endl;
  coordinates_file << "#   mu:                              " << mu                                                                             << std::endl;
  coordinates_file << "#   nu:                              " << nu                                                                             << std::endl;
  coordinates_file << "#   R:                               " << R                                                                              << std::endl;
  coordinates_file << "#"                                                                                                                       << std::endl;
  coordinates_file << "# Properties of the original graph:"                                                                                     << std::endl;
  coordinates_file << "#   Nb vertices:                     " << nb_vertices                                                                    << std::endl;
  coordinates_file << "#   Nb edges:                        " << nb_edges                                                                       << std::endl;
  coordinates_file << "#   Average degree:                  " << average_degree                                                                 << std::endl;
  coordinates_file << "#   Minimum in-degree:               " << degree_histogram[in__deg_idx].begin()->first                                   << std::endl;
  coordinates_file << "#   Minimum out-degree:              " << degree_histogram[out_deg_idx].begin()->first                                   << std::endl;
  coordinates_file << "#   Maximum in-degree:               " << (--degree_histogram[in__deg_idx].end())->first                                 << std::endl;
  coordinates_file << "#   Maximum out-degree:              " << (--degree_histogram[out_deg_idx].end())->first                                 << std::endl;
  coordinates_file << "#   Nb of in-degree classes:         " << degree_histogram[in__deg_idx].size()                                           << std::endl;
  coordinates_file << "#   Nb of out-degree classes:        " << degree_histogram[out_deg_idx].size()                                           << std::endl;
  coordinates_file << "#   Avg. undir. local clust. coeff.: " << average_undir_clustering                                                       << std::endl;
  coordinates_file << "#   Reciprocity:                     " << reciprocity                                                                    << std::endl;
  coordinates_file << "#"                                                                                                                       << std::endl;
  coordinates_file << "# Expected properties of the inferred ensemble:"                                                                         << std::endl;
  coordinates_file << "#   Average degree:                  " << random_ensemble_average_degree                                                 << std::endl;
  // coordinates_file << "#   Minimum in-degree:               " << random_ensemble_expected_degree_per_degree_class[in__deg_idx].begin()->first   << std::endl;
  // coordinates_file << "#   Minimum out-degree:              " << random_ensemble_expected_degree_per_degree_class[out_deg_idx].begin()->first   << std::endl;
  // coordinates_file << "#   Maximum in-degree:               " << (--random_ensemble_expected_degree_per_degree_class[in__deg_idx].end())->first << std::endl;
  // coordinates_file << "#   Maximum out-degree:              " << (--random_ensemble_expected_degree_per_degree_class[out_deg_idx].end())->first << std::endl;
  coordinates_file << "#   Avg. undir. local clust. coeff.: " << random_ensemble_average_clustering                                             << std::endl;
  coordinates_file << "#   Reciprocity:                     " << random_ensemble_reciprocity                                                    << std::endl;
  coordinates_file << "#"                                                                                                                       << std::endl;
  coordinates_file << "# =~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=" << std::endl;
  coordinates_file << "#";
  coordinates_file << std::setw(width_names - 1)  << "Vertex"         << " ";
  coordinates_file << std::setw(width_values)     << "inKappa"        << " ";
  coordinates_file << std::setw(width_values)     << "outKappa"       << " ";
  coordinates_file << std::setw(width_values)     << "expInDegree"    << " ";
  coordinates_file << std::setw(width_values)     << "realInDegree"   << " ";
  coordinates_file << std::setw(width_values)     << "expOutDegree"   << " ";
  coordinates_file << std::setw(width_values)     << "realOutDegree"  << " ";
  // coordinates_file << std::setw(width_values)     << "Inf.Theta"       << " ";
  // coordinates_file << std::setw(width_values)     << "Inf.Hyp.Rad."    << " ";
  coordinates_file << std::endl;

  // Structure containing the desired method to compared strings (put shorter ones before longer ones).
  struct compare
  {
    bool operator()(const std::pair<std::string, int>& lhs, const std::pair<std::string, int>& rhs) const
    {
      if(lhs.first.size() == rhs.first.size())
      {
        if(lhs.first == rhs.first)
        {
          return lhs.second < rhs.second;
        }
        else
        {
          return lhs.first < rhs.first;
        }
      }
      else
      {
        return lhs.first.size() < rhs.first.size();
      }
    }
  };

  // Writes the hidden variables.
  std::set< std::pair<std::string, size_t>, compare > ordered_names(Name2Num.begin(), Name2Num.end());
  for(auto el: ordered_names)
  {
    coordinates_file << std::setw(width_names)  << el.first << " ";
    coordinates_file << std::setw(width_values) << random_ensemble_kappa_per_degree_class[in__deg_idx][degree[in__deg_idx][el.second]] << " ";
    coordinates_file << std::setw(width_values) << random_ensemble_kappa_per_degree_class[out_deg_idx][degree[out_deg_idx][el.second]] << " ";
    coordinates_file << std::setw(width_values) << random_ensemble_expected_degree_per_degree_class[in__deg_idx][degree[in__deg_idx][el.second]] << " ";
    coordinates_file << std::setw(width_values) << degree[in__deg_idx][el.second] << " ";
    coordinates_file << std::setw(width_values) << random_ensemble_expected_degree_per_degree_class[out_deg_idx][degree[out_deg_idx][el.second]] << " ";
    coordinates_file << std::setw(width_values) << degree[out_deg_idx][el.second] << " ";
    // coordinates_file << std::setw(width_values) << theta[v]                                                       << " ";
    // coordinates_file << std::setw(width_values) << hyp_radius - 2 * std::log( kappa[v] / kappa_min )              << " ";
    // // coordinates_file << std::setw(width) << 2 * std::log( nb_vertices / (PI * mu * kappa_min * kappa[v]) ) << " ";
    coordinates_file << std::endl;
  }
  coordinates_file << "#"                                                                                                                       << std::endl;
  coordinates_file << "# =~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=" << std::endl;
  coordinates_file << "# Internal parameters and options"                                                                          << std::endl;
//   coordinates_file << "# " << TAB << "ALREADY_INFERRED_PARAMETERS_FILENAME   " << ALREADY_INFERRED_PARAMETERS_FILENAME             << std::endl;
  coordinates_file << "# " << TAB << "BETA_ABS_MAX                           " << BETA_ABS_MAX                                     << std::endl;
  coordinates_file << "# " << TAB << "BETA_ABS_MIN                           " << BETA_ABS_MIN                                     << std::endl;
//   coordinates_file << "# " << TAB << "CHARACTERIZATION_MODE                  " << (CHARACTERIZATION_MODE       ? "true" : "false") << std::endl;
//   coordinates_file << "# " << TAB << "CHARACTERIZATION_NB_GRAPHS             " << CHARACTERIZATION_NB_GRAPHS                       << std::endl;
  coordinates_file << "# " << TAB << "CLEAN_RAW_OUTPUT_MODE                  " << (CLEAN_RAW_OUTPUT_MODE       ? "true" : "false") << std::endl;
//   // coordinates_file << "# " << TAB << "CLOSE_ANGULAR_RANGE_FACTOR             " << CLOSE_ANGULAR_RANGE_FACTOR                       << std::endl;
  coordinates_file << "# " << TAB << "CUSTOM_BETA                            " << (CUSTOM_BETA                 ? "true" : "false") << std::endl;
  coordinates_file << "# " << TAB << "CUSTOM_MU                              " << (CUSTOM_MU                   ? "true" : "false") << std::endl;
  coordinates_file << "# " << TAB << "CUSTOM_NU                              " << (CUSTOM_NU                   ? "true" : "false") << std::endl;
//   coordinates_file << "# " << TAB << "CUSTOM_INFERRED_COORDINATES            " << (CUSTOM_INFERRED_COORDINATES ? "true" : "false") << std::endl;
  coordinates_file << "# " << TAB << "CUSTOM_OUTPUT_ROOTNAME_MODE            " << (CUSTOM_OUTPUT_ROOTNAME_MODE ? "true" : "false") << std::endl;
  coordinates_file << "# " << TAB << "CUSTOM_SEED                            " << (CUSTOM_SEED                 ? "true" : "false") << std::endl;
  coordinates_file << "# " << TAB << "EDGELIST_FILENAME:                     " << EDGELIST_FILENAME                                << std::endl;
  coordinates_file << "# " << TAB << "EXP_CLUST_NB_INTEGRATION_MC_STEPS      " << EXP_CLUST_NB_INTEGRATION_MC_STEPS                << std::endl;
//   coordinates_file << "# " << TAB << "EXP_DIST_NB_INTEGRATION_STEPS          " << EXP_DIST_NB_INTEGRATION_STEPS                    << std::endl;
  coordinates_file << "# " << TAB << "KAPPA_MAX_NB_ITER_CONV                 " << KAPPA_MAX_NB_ITER_CONV                           << std::endl;
//   coordinates_file << "# " << TAB << "KAPPA_POST_INFERENCE_MODE              " << (KAPPA_POST_INFERENCE_MODE   ? "true" : "false") << std::endl;
//   // coordinates_file << "# " << TAB << "LIMIT_FOR_CONVERGENCE_CRITERION        " << LIMIT_FOR_CONVERGENCE_CRITERION                  << std::endl;
//   // coordinates_file << "# " << TAB << "MAX_NB_ITER_MAXIMIZATION               " << MAX_NB_ITER_MAXIMIZATION                         << std::endl;
//   coordinates_file << "# " << TAB << "MAXIMIZATION_MODE                      " << (MAXIMIZATION_MODE           ? "true" : "false") << std::endl;
//   // coordinates_file << "# " << TAB << "MINIMAL_ANGULAR_CONVERGENCE_THRESHOLD  " << MINIMAL_ANGULAR_CONVERGENCE_THRESHOLD            << std::endl;
//   // coordinates_file << "# " << TAB << "MINIMAL_ANGULAR_RESOLUTION             " << MINIMAL_ANGULAR_RESOLUTION                       << std::endl;
//   // coordinates_file << "# " << TAB << "NB_VERTICES_IN_CORE                    " << NB_VERTICES_IN_CORE                              << std::endl;
//   coordinates_file << "# " << TAB << "MIN_NB_ANGLES_TO_TRY                   " << MIN_NB_ANGLES_TO_TRY                             << std::endl;
//   coordinates_file << "# " << TAB << "NUMERICAL_CONVERGENCE_THRESHOLD_1      " << NUMERICAL_CONVERGENCE_THRESHOLD_1                << std::endl;
//   coordinates_file << "# " << TAB << "NUMERICAL_CONVERGENCE_THRESHOLD_2      " << NUMERICAL_CONVERGENCE_THRESHOLD_2                << std::endl;
//   coordinates_file << "# " << TAB << "NUMERICAL_CONVERGENCE_THRESHOLD_3      " << NUMERICAL_CONVERGENCE_THRESHOLD_3                << std::endl;
  coordinates_file << "# " << TAB << "NUMERICAL_ZERO                         " << NUMERICAL_ZERO                                   << std::endl;
  coordinates_file << "# " << TAB << "QUIET_MODE                             " << (QUIET_MODE                  ? "true" : "false") << std::endl;
//   coordinates_file << "# " << TAB << "REFINE_MODE                            " << (REFINE_MODE                 ? "true" : "false") << std::endl;
//   // coordinates_file << "# " << TAB << "REFINED_MAX_STEP_LENGTH_DIVISOR        " << REFINED_MAX_STEP_LENGTH_DIVISOR                  << std::endl;
  coordinates_file << "# " << TAB << "ROOTNAME_OUTPUT:                       " << ROOTNAME_OUTPUT                                  << std::endl;
  coordinates_file << "# " << TAB << "SEED                                   " << SEED                                             << std::endl;
//   coordinates_file << "# " << TAB << "VALIDATION_MODE                        " << (VALIDATION_MODE             ? "true" : "false") << std::endl;
  coordinates_file << "# " << TAB << "VERBOSE_MODE                           " << (VERBOSE_MODE                ? "true" : "false") << std::endl;
  coordinates_file << "# " << TAB << "VERSION                                " << VERSION                                          << std::endl;
//   coordinates_file << "# =~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~="        << std::endl;
  // Closes the stream.
  coordinates_file.close();

  if(!QUIET_MODE) { std::clog << std::endl; }
  if(!QUIET_MODE) { std::clog << TAB << "=> Inferred parameters saved to " << ROOTNAME_OUTPUT + "_infparams.txt" << std::endl; }

  if(CLEAN_RAW_OUTPUT_MODE)
  {
    // Sets the name of the file to write the hidden variables into.
    coordinates_filename = ROOTNAME_OUTPUT + "_rawinfparams.txt";
    // Opens the stream and terminates if the operation did not succeed.
    coordinates_file.open(coordinates_filename.c_str(), std::fstream::out);
    if( !coordinates_file.is_open() )
    {
      std::cerr << "Could not open file: " << coordinates_filename << "." << std::endl;
      std::terminate();
    }
    for(auto el: ordered_names)
    {
      coordinates_file << std::setw(width_names)  << el.first << " ";
      coordinates_file << std::setw(width_values) << random_ensemble_kappa_per_degree_class[in__deg_idx][degree[in__deg_idx][el.second]] << " ";
      coordinates_file << std::setw(width_values) << random_ensemble_kappa_per_degree_class[out_deg_idx][degree[out_deg_idx][el.second]] << " ";
      // coordinates_file << std::setw(width_values) << random_ensemble_expected_degree_per_degree_class[in__deg_idx][degree[in__deg_idx][el.second]] << " ";
      // coordinates_file << std::setw(width_values) << degree[in__deg_idx][el.second] << " ";
      // coordinates_file << std::setw(width_values) << random_ensemble_expected_degree_per_degree_class[out_deg_idx][degree[out_deg_idx][el.second]] << " ";
      // coordinates_file << std::setw(width_values) << degree[out_deg_idx][el.second] << " ";
      // // coordinates_file << std::setw(width_values) << theta[v]                                                       << " ";
      // // coordinates_file << std::setw(width_values) << hyp_radius - 2 * std::log( kappa[v] / kappa_min )              << " ";
      // // // coordinates_file << std::setw(width) << 2 * std::log( nb_vertices / (PI * mu * kappa_min * kappa[v]) ) << " ";
      coordinates_file << std::endl;
    }
    // Closes the stream.
    coordinates_file.close();

    if(!QUIET_MODE) { std::clog << std::endl; }
    if(!QUIET_MODE) { std::clog << TAB << "=> Raw inferred parameters also saved to " << ROOTNAME_OUTPUT + "_rawinfparams.txt" << std::endl; }
  }
//
//   if(warning)
//   {
//     if(!QUIET_MODE) { std::clog << "WARNING: Hyperbolic radius has been adjusted to account for negative radial positions." << std::endl; }
//   }
}


// // =~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=
// // =~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=
// void fitting_directedS1_t::save_inferred_ensemble_characterization()
// {
//   if(!QUIET_MODE) { std::clog << std::endl; }
//   if(!QUIET_MODE) { std::clog << "Characterizing the inferred ensemble..." << std::endl; }
//   // Iterators.
//   std::map<int, double>::iterator it2, end2;
//   std::map<int, std::vector<double> >::iterator it3, end3;
//   // Initializes the containers.
//   characterizing_inferred_ensemble_vprops.clear();
//   characterizing_inferred_ensemble_vprops.resize(5);
//   for(int i(0); i<characterizing_inferred_ensemble_vprops.size(); ++i)
//   {
//     characterizing_inferred_ensemble_vprops[i].clear();
//     characterizing_inferred_ensemble_vprops[i].resize(nb_vertices, std::vector<double>(2, 0));
//   }
//   characterizing_inferred_ensemble_vstat.clear();
//   // Objects to compute the complementary cumulative degree distribution.
//   std::vector<double> single_comp_cumul_degree_dist;
//   std::vector<double> avg_comp_cumul_degree_dist;
//   std::vector<double> std_comp_cumul_degree_dist;
//   std::vector<int> nb_comp_cumul_degree_dist;
//   // Sets the number of graphs to be generated in function of the size of the original graph.
//   if(!CUSTOM_CHARACTERIZATION_NB_GRAPHS)
//   {
//     if     (nb_vertices < 500  ) { CHARACTERIZATION_NB_GRAPHS = 1000; }
//     else if(nb_vertices < 1000 ) { CHARACTERIZATION_NB_GRAPHS = 500;  }
//     else if(nb_vertices < 10000) { CHARACTERIZATION_NB_GRAPHS = 100;  }
//     else                         { CHARACTERIZATION_NB_GRAPHS = 10;   }
//   }
//   if(!QUIET_MODE) { std::clog << std::endl; }
//   if(!QUIET_MODE) { std::clog << TAB << "A total of " << CHARACTERIZATION_NB_GRAPHS << " graphs will be generated (chosen in function of the total number" << std::endl; }
//   if(!QUIET_MODE) { std::clog << TAB << "of vertices). To change this value, set the flag 'CUSTOM_CHARACTERIZATION_NB_GRAPHS'" << std::endl; }
//   if(!QUIET_MODE) { std::clog << TAB << "to 'true' and set the variable 'CHARACTERIZATION_NB_GRAPHS' to the desired value." << std::endl; }
//   if(!QUIET_MODE) { std::clog << std::endl; }
//   // Performs the simulations.
//   int delta_nb_graphs = CHARACTERIZATION_NB_GRAPHS / 19.999999;
//   if(delta_nb_graphs < 1) { delta_nb_graphs = 1; }
//   int width = 2 * (std::log10(CHARACTERIZATION_NB_GRAPHS) + 1) + 6;
//   double d1, value;
//   std::string graph_range;
//   double start_time, stop_time;
//   for(int g_i(0), g_f, d_max; g_i<CHARACTERIZATION_NB_GRAPHS;)
//   {
//     g_f = (g_i + delta_nb_graphs);
//     g_f = (g_f > CHARACTERIZATION_NB_GRAPHS) ? CHARACTERIZATION_NB_GRAPHS : g_f;
//     start_time = time_since_epoch_in_seconds();
//     if(!QUIET_MODE) { graph_range = "[" + std::to_string(g_i+1) + "," + std::to_string(g_f) + "]..."; }
//     if(!QUIET_MODE) { std::clog << TAB << "Generating and analyzing graphs " << std::setw(width) << graph_range; }
//     for(; g_i<g_f; ++g_i)
//     {
//       single_comp_cumul_degree_dist.clear();
//       generate_simulated_adjacency_list();
//       analyze_simulated_adjacency_list();
//       for(int v1(0); v1<nb_vertices; ++v1)
//       {
//         // Degree.
//         d1 = simulated_degree[v1];
//         characterizing_inferred_ensemble_vprops[0][v1][0] += d1;
//         characterizing_inferred_ensemble_vprops[0][v1][1] += d1 * d1;
//         if(d1 > 0)
//         {
//           // Sum of the degree of neighbors.
//           value = simulated_sum_degree_of_neighbors[v1];
//           characterizing_inferred_ensemble_vprops[1][v1][0] += value;
//           characterizing_inferred_ensemble_vprops[1][v1][1] += value * value;
//           // Average degree of neighbors.
//           value /= d1;
//           characterizing_inferred_ensemble_vprops[2][v1][0] += value;
//           characterizing_inferred_ensemble_vprops[2][v1][1] += value * value;
//         }
//         if(d1 > 1)
//         {
//           // Number of triangles attached on the vertex.
//           value = simulated_nb_triangles[v1];
//           characterizing_inferred_ensemble_vprops[3][v1][0] += value;
//           characterizing_inferred_ensemble_vprops[3][v1][1] += value * value;
//           // Clustering coefficient.
//           value /= d1 * (d1 - 1) / 2;
//           characterizing_inferred_ensemble_vprops[4][v1][0] += value;
//           characterizing_inferred_ensemble_vprops[4][v1][1] += value * value;
//         }
//       }
//       // Compiles the various statistics about the degree classes.
//       it2 = simulated_stat_degree.begin();
//       end2 = simulated_stat_degree.end();
//       d_max = -1;
//       // single_comp_cumul_degree_dist.clear();
//       for(int d, norm; it2!=end2; ++it2)
//       {
//         // Gets the degree class.
//         d = it2->first;
//         // Initializes the degree class if it has not been encountered yet.
//         if( characterizing_inferred_ensemble_vstat.find(d) == characterizing_inferred_ensemble_vstat.end() )
//         {
//           characterizing_inferred_ensemble_vstat[d] = std::vector<double>((2 * 5) + 1, 0);
//         }
//         // // Adjusts the size of the vector containing the complementary cumulative distribution if necessary.
//         if(d > d_max)
//         {
//           d_max = d;
//           single_comp_cumul_degree_dist.resize(d_max + 1, 0);
//         }
//         // Gets the number of vertices in this degree class.
//         norm = it2->second;
//         // Degree distribution.
//         value = simulated_stat_degree[d] / nb_vertices;
//         characterizing_inferred_ensemble_vstat[d][0] += value;
//         characterizing_inferred_ensemble_vstat[d][1] += value * value;
//         // Complementary cumulative degree distribution.
//         for(int q(0); q<=d; ++q)
//         {
//           single_comp_cumul_degree_dist[q] += value;
//           // comp_cumul_degree_dist_n[q] += 1;
//         }
//         // Sum of the degree of neighbors.
//         value = simulated_stat_sum_degree_neighbors[d] / norm;
//         characterizing_inferred_ensemble_vstat[d][2] += value;
//         characterizing_inferred_ensemble_vstat[d][3] += value * value;
//         // Average of the degree of neighbors.
//         value = simulated_stat_avg_degree_neighbors[d] / norm;
//         characterizing_inferred_ensemble_vstat[d][4] += value;
//         characterizing_inferred_ensemble_vstat[d][5] += value * value;
//         // Number of triangles attached on the vertex.
//         value = simulated_stat_nb_triangles[d] / norm;
//         characterizing_inferred_ensemble_vstat[d][6] += value;
//         characterizing_inferred_ensemble_vstat[d][7] += value * value;
//         // Clustering coefficient.
//         value = simulated_stat_clustering[d] / norm;
//         characterizing_inferred_ensemble_vstat[d][8] += value;
//         characterizing_inferred_ensemble_vstat[d][9] += value * value;
//         // Counts the number of time the degree class has been observed.
//         characterizing_inferred_ensemble_vstat[d][10] += 1;
//       }
//       // Counts which degree classes have been reached.
//       if((d_max + 1) > nb_comp_cumul_degree_dist.size())
//       {
//         avg_comp_cumul_degree_dist.resize(d_max + 1, 0);
//         std_comp_cumul_degree_dist.resize(d_max + 1, 0);
//         nb_comp_cumul_degree_dist.resize(d_max + 1, 0);
//       }
//       for(int r(0); r<=d_max; ++r)
//       {
//         avg_comp_cumul_degree_dist[r] += single_comp_cumul_degree_dist[r];
//         std_comp_cumul_degree_dist[r] += single_comp_cumul_degree_dist[r] * single_comp_cumul_degree_dist[r];
//         nb_comp_cumul_degree_dist[r] += 1;
//       }
//     }
//     // Compiles the complementary cumulative degree distribution.
//     stop_time = time_since_epoch_in_seconds();
//     if(!QUIET_MODE) { std::clog << "...done in " << std::setw(6) << std::fixed << stop_time - start_time << " seconds" << std::endl; }
//   }
//   // Finalizes the characterization.
//   for(int i(0); i<characterizing_inferred_ensemble_vprops.size(); ++i)
//   {
//     for(int v1(0); v1<nb_vertices; ++v1)
//     {
//       characterizing_inferred_ensemble_vprops[i][v1][0] /= CHARACTERIZATION_NB_GRAPHS;
//       characterizing_inferred_ensemble_vprops[i][v1][1] /= CHARACTERIZATION_NB_GRAPHS;
//       characterizing_inferred_ensemble_vprops[i][v1][1] -= characterizing_inferred_ensemble_vprops[i][v1][0] * characterizing_inferred_ensemble_vprops[i][v1][0];
//       characterizing_inferred_ensemble_vprops[i][v1][1] *= CHARACTERIZATION_NB_GRAPHS / (CHARACTERIZATION_NB_GRAPHS - 1);
//       characterizing_inferred_ensemble_vprops[i][v1][1] = std::sqrt( characterizing_inferred_ensemble_vprops[i][v1][1] );
//     }
//   }
//   it3 = characterizing_inferred_ensemble_vstat.begin();
//   end3 = characterizing_inferred_ensemble_vstat.end();
//   for(int norm, d; it3!=end3; ++it3)
//   {
//     d = it3->first;
//     norm = characterizing_inferred_ensemble_vstat[d][10];
//     for(int i(0); i<10; ++++i)
//     {
//       characterizing_inferred_ensemble_vstat[d][i + 0] /= norm;
//       if(norm > 1)
//       {
//         characterizing_inferred_ensemble_vstat[d][i + 1] /= norm;
//         characterizing_inferred_ensemble_vstat[d][i + 1] -= characterizing_inferred_ensemble_vstat[d][i + 0] * characterizing_inferred_ensemble_vstat[d][i + 0];
//         characterizing_inferred_ensemble_vstat[d][i + 1] *= norm / (norm - 1);
//         if( characterizing_inferred_ensemble_vstat[d][i + 1] < 0 )
//         {
//           characterizing_inferred_ensemble_vstat[d][i + 1] = 0;
//         }
//         else
//         {
//           characterizing_inferred_ensemble_vstat[d][i + 1] = std::sqrt( characterizing_inferred_ensemble_vstat[d][i + 1] );
//         }
//       }
//       else
//       {
//         characterizing_inferred_ensemble_vstat[d][i + 1] = 0;
//       }
//     }
//   }
//   // Complete the characterization of the complementary cumulative degree distribution.
//   for(int i(0), ii(nb_comp_cumul_degree_dist.size()); i<ii; ++i)
//   {
//     if(nb_comp_cumul_degree_dist[i] > 0)
//     {
//       avg_comp_cumul_degree_dist[i] /= nb_comp_cumul_degree_dist[i];
//       if(nb_comp_cumul_degree_dist[i] > 1)
//       {
//         std_comp_cumul_degree_dist[i] /= nb_comp_cumul_degree_dist[i];
//         std_comp_cumul_degree_dist[i] -= avg_comp_cumul_degree_dist[i] * avg_comp_cumul_degree_dist[i];
//         std_comp_cumul_degree_dist[i] *= nb_comp_cumul_degree_dist[i] / (nb_comp_cumul_degree_dist[i] - 1);
//         if(std_comp_cumul_degree_dist[i] < 0)
//         {
//           std_comp_cumul_degree_dist[i] = 0;
//         }
//         else
//         {
//           std_comp_cumul_degree_dist[i] = std::sqrt(std_comp_cumul_degree_dist[i]);
//         }
//       }
//       else
//       {
//         std_comp_cumul_degree_dist[i] = 0;
//       }
//     }
//   }
//   if(!QUIET_MODE) { std::clog << "                                       ...............................................done." << std::endl; }
//   // Sets the name of the file to write the vertices properties into.
//   std::string vertex_properties_filename = ROOTNAME_OUTPUT + ".inf_vprop";
//   // Opens the stream and terminates if the operation did not succeed.
//   std::fstream vertex_properties_file(vertex_properties_filename.c_str(), std::fstream::out);
//   if( !vertex_properties_file.is_open() )
//   {
//     std::cerr << "Could not open file: " << vertex_properties_filename << "." << std::endl;
//     std::terminate();
//   }
//   // Writes the header.
//   vertex_properties_file << "#";
//   vertex_properties_file << std::setw(width_names - 1) << "Vertex"          << " ";
//   vertex_properties_file << std::setw(width_values)     << "Degree"          << " ";
//   vertex_properties_file << std::setw(width_values)     << "Avg.Degree"      << " ";
//   vertex_properties_file << std::setw(width_values)     << "Std.Degree"      << " ";
//   vertex_properties_file << std::setw(width_values)     << "Sum.Deg.N"       << " ";
//   vertex_properties_file << std::setw(width_values)     << "Avg.Sum.Deg.N"   << " ";
//   vertex_properties_file << std::setw(width_values)     << "Std.Sum.Deg.N"   << " ";
//   vertex_properties_file << std::setw(width_values)     << "Avg.Deg.N"       << " ";
//   vertex_properties_file << std::setw(width_values)     << "Avg.Avg.Deg.N"   << " ";
//   vertex_properties_file << std::setw(width_values)     << "Std.Avg.Deg.N"   << " ";
//   vertex_properties_file << std::setw(width_values)     << "NbTriang"        << " ";
//   vertex_properties_file << std::setw(width_values)     << "Avg.NbTriang"    << " ";
//   vertex_properties_file << std::setw(width_values)     << "Std.NbTriang"    << " ";
//   vertex_properties_file << std::setw(width_values)     << "Clustering"      << " ";
//   vertex_properties_file << std::setw(width_values)     << "Avg.Clustering"  << " ";
//   vertex_properties_file << std::setw(width_values)     << "Std.Clustering"  << " ";
//   vertex_properties_file << std::endl;
//   // Structure containing the desired method to compared strings (put shorter ones before longer ones).
//   struct compare
//   {
//     bool operator()(const std::pair<std::string, int>& lhs, const std::pair<std::string, int>& rhs) const
//     {
//       if(lhs.first.size() == rhs.first.size())
//       {
//         if(lhs.first == rhs.first)
//         {
//           return lhs.second < rhs.second;
//         }
//         else
//         {
//           return lhs.first < rhs.first;
//         }
//       }
//       else
//       {
//         return lhs.first.size() < rhs.first.size();
//       }
//     }
//   };
//   // Writes the hidden variables.
//   std::set< std::pair<std::string, int>, compare > ordered_names;
//   for(int v(0); v<nb_vertices; ++v)
//   {
//     ordered_names.insert(std::make_pair(Num2Name[v], v));
//   }
//   std::set< std::pair<std::string, int> >::iterator it  = ordered_names.begin();
//   std::set< std::pair<std::string, int> >::iterator end = ordered_names.end();
//   for(int v, d; it!=end; ++it)
//   {
//     v = it->second;
//     d = degree[v];
//     vertex_properties_file << std::setw(width_names) << it->first                                        << " ";
//     vertex_properties_file << std::setw(width_values) << degree[v]                                        << " ";
//     vertex_properties_file << std::setw(width_values) << characterizing_inferred_ensemble_vprops[0][v][0] << " ";
//     vertex_properties_file << std::setw(width_values) << characterizing_inferred_ensemble_vprops[0][v][1] << " ";
//     vertex_properties_file << std::setw(width_values) << sum_degree_of_neighbors[v]                       << " ";
//     vertex_properties_file << std::setw(width_values) << characterizing_inferred_ensemble_vprops[1][v][0] << " ";
//     vertex_properties_file << std::setw(width_values) << characterizing_inferred_ensemble_vprops[1][v][1] << " ";
//     if(d > 0)
//     {
//       vertex_properties_file << std::setw(width_values) << sum_degree_of_neighbors[v] / d                 << " ";
//     }
//     else
//     {
//       vertex_properties_file << std::setw(width_values) << sum_degree_of_neighbors[v]                     << " ";
//     }
//     vertex_properties_file << std::setw(width_values) << characterizing_inferred_ensemble_vprops[2][v][0] << " ";
//     vertex_properties_file << std::setw(width_values) << characterizing_inferred_ensemble_vprops[2][v][1] << " ";
//     vertex_properties_file << std::setw(width_values) << nbtriangles[v]                                   << " ";
//     vertex_properties_file << std::setw(width_values) << characterizing_inferred_ensemble_vprops[3][v][0] << " ";
//     vertex_properties_file << std::setw(width_values) << characterizing_inferred_ensemble_vprops[3][v][1] << " ";
//     if(d > 1)
//     {
//       vertex_properties_file << std::setw(width_values) << nbtriangles[v] / (d * (d-1) / 2)               << " ";
//     }
//     else
//     {
//       vertex_properties_file << std::setw(width_values) << nbtriangles[v]                                 << " ";
//     }
//     vertex_properties_file << std::setw(width_values) << characterizing_inferred_ensemble_vprops[4][v][0] << " ";
//     vertex_properties_file << std::setw(width_values) << characterizing_inferred_ensemble_vprops[4][v][1] << " ";
//     vertex_properties_file << std::endl;
//   }
//   vertex_properties_file.close();
//   if(!QUIET_MODE) { std::clog << std::endl; }
//   if(!QUIET_MODE) { std::clog << TAB << "=> Vertices properties of the inferred ensemble saved to " << ROOTNAME_OUTPUT + ".inf_vprop" << std::endl; }
//
//   // Sets the name of the file to write the vertices properties into.
//   std::string vertex_stat_filename = ROOTNAME_OUTPUT + ".inf_vstat";
//   // Opens the stream and terminates if the operation did not succeed.
//   std::fstream vertex_stat_file(vertex_stat_filename.c_str(), std::fstream::out);
//   if( !vertex_stat_file.is_open() )
//   {
//     std::cerr << "Could not open file: " << vertex_stat_filename << "." << std::endl;
//     std::terminate();
//   }
//   // Writes the header.
//   vertex_stat_file << "#";
//   vertex_stat_file << std::setw(width_values - 1) << "Degree"          << " ";
//   // vertex_stat_file << std::setw(width_values)     << "DegDistObs"      << " ";
//   vertex_stat_file << std::setw(width_values)     << "DegDistEns"      << " ";
//   vertex_stat_file << std::setw(width_values)     << "DegDistEnsStd"   << " ";
//   vertex_stat_file << std::setw(width_values)     << "CDegDistEns"      << " ";
//   vertex_stat_file << std::setw(width_values)     << "CDegDistEnsStd"   << " ";
//   // vertex_stat_file << std::setw(width_values)     << "SumDegNObs"      << " ";
//   vertex_stat_file << std::setw(width_values)     << "SumDegNEns"      << " ";
//   vertex_stat_file << std::setw(width_values)     << "SumDegNEnsStd"   << " ";
//   // vertex_stat_file << std::setw(width_values)     << "AvgDegNObs"      << " ";
//   vertex_stat_file << std::setw(width_values)     << "AvgDegNEns"      << " ";
//   vertex_stat_file << std::setw(width_values)     << "AvgDegNEnsStd"   << " ";
//   // vertex_stat_file << std::setw(width_values)     << "NbTriangObs"     << " ";
//   vertex_stat_file << std::setw(width_values)     << "NbTriangEns"     << " ";
//   vertex_stat_file << std::setw(width_values)     << "NbTriangEnsStd"  << " ";
//   // vertex_stat_file << std::setw(width_values)     << "ClustObs"        << " ";
//   vertex_stat_file << std::setw(width_values)     << "ClustEns"        << " ";
//   vertex_stat_file << std::setw(width_values)     << "ClustEnsStd"     << " ";
//   vertex_stat_file << std::endl;
//   // Writes the hidden variables.
//   it3 = characterizing_inferred_ensemble_vstat.begin();
//   end3 = characterizing_inferred_ensemble_vstat.end();
//   for(int v, d; it3!=end3; ++it3)
//   {
//     d = it3->first;
//     vertex_stat_file << std::setw(width_values) << d                                            << " ";
//     vertex_stat_file << std::setw(width_values) << characterizing_inferred_ensemble_vstat[d][0] << " ";
//     vertex_stat_file << std::setw(width_values) << characterizing_inferred_ensemble_vstat[d][1] << " ";
//     vertex_stat_file << std::setw(width_values) << avg_comp_cumul_degree_dist[d]                << " ";
//     vertex_stat_file << std::setw(width_values) << std_comp_cumul_degree_dist[d]                << " ";
//     vertex_stat_file << std::setw(width_values) << characterizing_inferred_ensemble_vstat[d][2] << " ";
//     vertex_stat_file << std::setw(width_values) << characterizing_inferred_ensemble_vstat[d][3] << " ";
//     vertex_stat_file << std::setw(width_values) << characterizing_inferred_ensemble_vstat[d][4] << " ";
//     vertex_stat_file << std::setw(width_values) << characterizing_inferred_ensemble_vstat[d][5] << " ";
//     vertex_stat_file << std::setw(width_values) << characterizing_inferred_ensemble_vstat[d][6] << " ";
//     vertex_stat_file << std::setw(width_values) << characterizing_inferred_ensemble_vstat[d][7] << " ";
//     vertex_stat_file << std::setw(width_values) << characterizing_inferred_ensemble_vstat[d][8] << " ";
//     vertex_stat_file << std::setw(width_values) << characterizing_inferred_ensemble_vstat[d][9] << " ";
//     vertex_stat_file << std::endl;
//   }
//   vertex_stat_file.close();
//   if(!QUIET_MODE) { std::clog << std::endl; }
//   if(!QUIET_MODE) { std::clog << TAB << "=> Inferred ensemble statistics by degree class saved to " << ROOTNAME_OUTPUT + ".inf_vstat" << std::endl; }
//
//
//   if(!QUIET_MODE) { std::clog << std::endl; }
//   if(!QUIET_MODE) { std::clog << "Extracting the original graph statistics by degree class..."; }
//
//
//   // Extracts the vertex statistics of the original edgelist by degree class.
//   std::map<int, double> original_stat_degree;
//   std::map<int, double> original_stat_sum_degree_neighbors;
//   std::map<int, double> original_stat_avg_degree_neighbors;
//   std::map<int, double> original_stat_nb_triangles;
//   std::map<int, double> original_stat_clustering;
//   for(int v1(0), d1; v1<nb_vertices; ++v1)
//   {
//     // Gets the degree of the vertex in the current generated graph.
//     d1 = degree[v1];
//     // Adds the key to the various map containers if this degree class has not been encountered yet.
//     if( original_stat_degree.find(d1) == original_stat_degree.end() )
//     {
//       original_stat_degree[d1] = 0;
//       original_stat_sum_degree_neighbors[d1] = 0;
//       original_stat_avg_degree_neighbors[d1] = 0;
//       original_stat_nb_triangles[d1] = 0;
//       original_stat_clustering[d1] = 0;
//     }
//     // Compiles the average quantities by degree class.
//     original_stat_degree[d1] += 1;
//     if(d1 > 0)
//     {
//       original_stat_sum_degree_neighbors[d1] += sum_degree_of_neighbors[v1];
//       original_stat_avg_degree_neighbors[d1] += sum_degree_of_neighbors[v1] / d1;
//     }
//     if(d1 > 1)
//     {
//       original_stat_nb_triangles[d1] += nbtriangles[v1];
//       original_stat_clustering[d1] += 2 * nbtriangles[v1] / d1 / (d1 - 1);
//     }
//   }
//   if(!QUIET_MODE) { std::clog << "...........................done." << std::endl; }
//
//   // Sets the name of the file to write the vertices properties into.
//   std::string graph_stat_filename = ROOTNAME_OUTPUT + ".obs_vstat";
//   // Opens the stream and terminates if the operation did not succeed.
//   std::fstream graph_stat_file(graph_stat_filename.c_str(), std::fstream::out);
//   if( !graph_stat_file.is_open() )
//   {
//     std::cerr << "Could not open file: " << graph_stat_filename << "." << std::endl;
//     std::terminate();
//   }
//
//   // Writes the header.
//   graph_stat_file << "#";
//   graph_stat_file << std::setw(width_values - 1) << "Degree"          << " ";
//   graph_stat_file << std::setw(width_values)     << "DegDist"         << " ";
//   graph_stat_file << std::setw(width_values)     << "CDegDist"        << " ";
//   graph_stat_file << std::setw(width_values)     << "SumDegN"         << " ";
//   graph_stat_file << std::setw(width_values)     << "AvgDegN"         << " ";
//   graph_stat_file << std::setw(width_values)     << "NbTriang"        << " ";
//   graph_stat_file << std::setw(width_values)     << "Clust"           << " ";
//   graph_stat_file << std::endl;
//   // Writes the hidden variables.
//   double ccdegdist = 1;
//   it2 = original_stat_degree.begin();
//   end2 = original_stat_degree.end();
//   for(int v, d, norm; it2!=end2; ++it2)
//   {
//     d = it2->first;
//     norm = it2->second;
//     graph_stat_file << std::setw(width_values) << d                                                   << " ";
//     graph_stat_file << std::setw(width_values) << original_stat_degree[d] / nb_vertices               << " ";
//     graph_stat_file << std::setw(width_values) << ccdegdist                                           << " ";
//     ccdegdist -= original_stat_degree[d] / nb_vertices;
//     graph_stat_file << std::setw(width_values) << original_stat_sum_degree_neighbors[d] / norm        << " ";
//     graph_stat_file << std::setw(width_values) << original_stat_avg_degree_neighbors[d] / norm        << " ";
//     graph_stat_file << std::setw(width_values) << original_stat_nb_triangles[d] / norm                << " ";
//     graph_stat_file << std::setw(width_values) << original_stat_clustering[d] / norm                  << " ";
//     graph_stat_file << std::endl;
//   }
//   graph_stat_file.close();
//
//   if(!QUIET_MODE) { std::clog << std::endl; }
//   if(!QUIET_MODE) { std::clog << TAB << "=> Original graph statistics by degree class saved to " << ROOTNAME_OUTPUT + ".obs_vstat" << std::endl; }
//   // // Gets the current time.
//   // time2 = std::time(NULL);
// }


// // =~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=
// // =~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=
// void fitting_directedS1_t::save_inferred_theta_density()
// {
//   // Builds the bins.
//   std::map<double, int> bins;
//   std::map<double, int>::iterator it;
//   int cnt = 0;
//   int nb_bins = 25;
//   double dt = 2 * PI / nb_bins;
//   for(double t(dt), tt(2 * PI + 0.001); t<tt; t+=dt, ++cnt)
//   {
//     bins[t] = cnt;
//   }
//   // Builds the containers.
//   std::vector<double> n(bins.size(), 0);
//   // Computes the connection probability for every pair of vertices.
//   for(int v1(0), i; v1<nb_vertices; ++v1)
//   {
//     i = bins.upper_bound(theta[v1])->second;
//     n[i] += 1;
//   }
//   // Writes the connection probability into a file.
//   std::string theta_density_filename = ROOTNAME_OUTPUT + ".inf_theta_density";
//   std::fstream theta_density_file(theta_density_filename.c_str(), std::fstream::out);
//   if( !theta_density_file.is_open() )
//   {
//     std::cerr << "Could not open file: " << theta_density_filename << "." << std::endl;
//     std::terminate();
//   }
//   theta_density_file << "#";
//   theta_density_file << std::setw(width_values - 1) << "Theta"       << " ";
//   theta_density_file << std::setw(width_values)     << "InfDensity"  << " ";
//   theta_density_file << std::setw(width_values)     << "ThDensity"   << " ";
//   theta_density_file << std::endl;
//   for(int i(0), ii(n.size()); i<ii; ++i)
//   {
//     theta_density_file << std::setw(width_values) << ((i + 0.5) * dt)    << " ";
//     theta_density_file << std::setw(width_values) << n[i] / nb_vertices  << " ";
//     theta_density_file << std::setw(width_values) << 1.0 / (nb_bins - 1) << " ";
//     theta_density_file << std::endl;
//   }
//   // Closes the stream.
//   theta_density_file.close();
//   if(!QUIET_MODE) { std::clog << std::endl; }
//   if(!QUIET_MODE) { std::clog << TAB << "=> Inferred theta density saved to " << ROOTNAME_OUTPUT + ".inf_theta_density" << std::endl; }
// }


// // =~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=
// // =~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=
// double fitting_directedS1_t::time_since_epoch_in_seconds()
// {
//   // double tmp = std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::system_clock::now().time_since_epoch()).count();
//   // return tmp / 1000;
//   // https://en.cppreference.com/w/cpp/chrono/c/clock
//   clock_t t = clock();
//   return ((float)t) / (CLOCKS_PER_SEC);
// }


// // =~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=
// // =~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=
// int fitting_directedS1_t::get_root(int i, std::vector<int> &clust_id)
// {
//   while(i != clust_id[i])
//   {
//     clust_id[i] = clust_id[clust_id[i]];
//     i = clust_id[i];
//   }
//   return i;
// }


// // =~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=
// // =~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=
// void fitting_directedS1_t::merge_clusters(std::vector<int> &size, std::vector<int> &clust_id)
// {
//   // Variables.
//   int v1, v2, v3, v4;
//   // Iterators.
//   std::set<int>::iterator it, end;
//   // Loops over the vertices.
//   for(int i(0); i<nb_vertices; ++i)
//   {
//     // Loops over the neighbors.
//     it  = adjacency_list[i].begin();
//     end = adjacency_list[i].end();
//     for(; it!=end; ++it)
//     {
//       if(get_root(i, clust_id) != get_root(*it, clust_id))
//       {
//         // Adjust the root of vertices.
//         v1 = i;
//         v2 = *it;
//         if(size[v2] > size[v1])
//           std::swap(v1, v2);
//         v3 = get_root(v1, clust_id);
//         v4 = get_root(v2, clust_id);
//         clust_id[v4] = v3;
//         size[v3] += size[v4];
//       }
//     }
//   }
// }


// // =~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=
// // =~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=
// void fitting_directedS1_t::check_connected_components()
// {
//   // Vector containing the ID of the component to which each node belongs.
//   std::vector<double> Vertex2Prop(nb_vertices, -1);
//
//   // Vector containing the size of the components.
//   std::vector<int> connected_components_size;
//
//   // Set ordering the component according to their size.
//   std::set< std::pair<int, int> > ordered_connected_components;
//
//   // Starts with every vertex as an isolated cluster.
//   std::vector<int> clust_id(nb_vertices);
//   std::vector<int> clust_size(nb_vertices, 1);
//   for(int v(0); v<nb_vertices; ++v)
//   {
//     clust_id[v] = v;
//   }
//   // Merges clusters until the minimal set is obtained.
//   merge_clusters(clust_size, clust_id);
//   clust_size.clear();
//   // Identifies the connected component to which each vertex belongs.
//   int nb_conn_comp = 0;
//   int comp_id;
//   std::map<int, int> CompID;
//   for(int v(0); v<nb_vertices; ++v)
//   {
//     comp_id = get_root(v, clust_id);
//     if(CompID.find(comp_id) == CompID.end())
//     {
//       CompID[comp_id] = nb_conn_comp;
//       connected_components_size.push_back(0);
//       ++nb_conn_comp;
//     }
//     Vertex2Prop[v] = CompID[comp_id];
//     connected_components_size[CompID[comp_id]] += 1;
//   }
//
//   // Orders the size of the components.
//   for(int c(0); c<nb_conn_comp; ++c)
//   {
//     ordered_connected_components.insert( std::make_pair(connected_components_size[c], c) );
//   }
//
//   int lcc_id = (--ordered_connected_components.end())->second;
//   int lcc_size = (--ordered_connected_components.end())->first;
//
//   if(lcc_size != nb_vertices)
//   {
//     if(!QUIET_MODE) { std::clog << std::endl; }
//     if(!QUIET_MODE) { std::clog << TAB << "- More than one component found!!" << std::endl; }
//     if(!QUIET_MODE) { std::clog << TAB << "- " << lcc_size << "/" << nb_vertices << " vertices in the largest component." << std::endl; }
//     std::cerr << std::endl;
//     std::cerr << "More than one component found (" << lcc_size << "/" << nb_vertices << " vertices in the largest component." << std::endl;
//
//     std::string edgelist_rootname;
//     size_t lastdot = EDGELIST_FILENAME.find_last_of(".");
//     if(lastdot == std::string::npos)
//     {
//       edgelist_rootname = EDGELIST_FILENAME;
//     }
//     edgelist_rootname = EDGELIST_FILENAME.substr(0, lastdot);
//
//     // Sets the name of the file to write the hidden variables into.
//     std::string edgelist_filename = edgelist_rootname + "_GC.edge";
//     // Opens the stream and terminates if the operation did not succeed.
//     std::fstream edgelist_file(edgelist_filename.c_str(), std::fstream::out);
//     if( !edgelist_file.is_open() )
//     {
//       std::cerr << "Could not open file: " << edgelist_filename << "." << std::endl;
//       std::terminate();
//     }
//
//     std::set<int>::iterator it, end;
//     for(int v1(0), v2, c1, c2; v1<nb_vertices; ++v1)
//     {
//       c1 = Vertex2Prop[v1];
//       if(c1 == lcc_id)
//       {
//         it  = adjacency_list[v1].begin();
//         end = adjacency_list[v1].end();
//         for(; it!=end; ++it)
//         {
//           v2 = *it;
//           c2 = Vertex2Prop[v2];
//           if(c2 == lcc_id)
//           {
//             if(v1 < v2)
//             {
//               edgelist_file << std::setw(width_names) << Num2Name[v1] << " ";
//               edgelist_file << std::setw(width_names) << Num2Name[v2] << " ";
//               edgelist_file << std::endl;
//             }
//           }
//         }
//       }
//     }
//     // Closes the stream.
//     edgelist_file.close();
//
//     if(!QUIET_MODE) { std::clog << TAB << "- Edges belonging to the largest component saved to " << edgelist_rootname + "_GC.edge." << std::endl; }
//     if(!QUIET_MODE) { std::clog << TAB << "- Please rerun the program using this new edgelist." << std::endl; }
//     if(!QUIET_MODE) { std::clog << std::endl; }
//     // if(!QUIET_MODE) { std::clog << "                                          "; }
//
//     if(QUIET_MODE)  { std::clog << std::endl; }
//     std::cerr << "Edges belonging to the largest component saved to " << edgelist_rootname + "_GC.edge. Please rerun the program using this new edgelist." << std::endl;
//     std::cerr << std::endl;
//     std::terminate();
//   }
// }





#endif // FITTING_DIRECTEDS1_HPP_INCLUDED
